จากเดิม :
if (qId != null && existingById.containsKey(qId)) {
    // อัปเดตคำถามเดิม
    question = existingById.get(qId);
    log.info("Updating existing question ID: {} for content {}", qId, id);
} else {
    // เพิ่มคำถามใหม่
    question = new QuestionEntity();
    String newId = generateId();
    question.setId(newId);
    question.setLearningContent(lc);
    em.persist(question);
    isNew = true;
    log.info("Creating new question ID: {} for content {}", newId, id);
}

เป็น : 
if (qId != null) {
    QuestionEntity existing = em.find(QuestionEntity.class, qId);
    if (existing != null) {
        question = existing;
        log.info("Reusing existing question ID: {} for content {}", qId, id);
    } else {
        question = new QuestionEntity();
        question.setId(qId); // ใช้ id เดิมจาก FE ถ้าไม่ชน
        question.setLearningContent(lc);
        em.persist(question);
        log.info("Creating new question with provided ID: {} for content {}", qId, id);
    }
} else {
    question = new QuestionEntity();
    question.setId(generateId()); // ไม่มี id จาก FE -> generate ใหม่
    question.setLearningContent(lc);
    em.persist(question);
    log.info("Creating new question with new ID: {} for content {}", question.getId(), id);
}

ส่วน choice dto : 
if (choice == null) {
    // choice ใหม่
    String newCid =
        (cId != null && em.find(QuestionChoiceEntity.class, cId) == null)
                ? cId
                : generateId();

    choice = new QuestionChoiceEntity();
    choice.setId(newCid);
    choice.setQuestion(question);
    existingChoices.add(choice); // cascade จะ persist ให้
    log.info("Creating new choice ID: {} for question {}", newCid, question.getId());
}

เป็น :
if (choice == null) {
    choice = new QuestionChoiceEntity();
    if (cId != null) {
        QuestionChoiceEntity existingChoice = em.find(QuestionChoiceEntity.class, cId);
        if (existingChoice != null) {
            choice = existingChoice; // ใช้ของเดิม
            log.info("Reusing existing choice ID: {} for question {}", cId, question.getId());
        } else {
            choice.setId(cId); // ใช้ id ที่ FE ส่งมา ถ้าไม่ชน
            log.info("Creating new choice with provided ID: {} for question {}", cId, question.getId());
        }
    } else {
        choice.setId(generateId()); // ไม่มี id -> generate ใหม่
        log.info("Creating new choice with new ID: {} for question {}", choice.getId(), question.getId());
    }
    choice.setQuestion(question);
    existingChoices.add(choice);
}


FE:
export type QuestionForm = {
  questionId?: string; // เพิ่ม
  questionText: string;
  type: "multiple" | "fill_blank";
  points?: number;
  options: string[];
  correctAnswers: string[];
  choiceIds?: string[]; // เพิ่ม ถ้าระบุได้
};
2. ปรับ payload ใน handleVideoSubmit()

ให้แน่ใจว่าส่งทั้ง questionId และ choiceId กลับไป
formData.append(
  "questions",
  JSON.stringify(
    form.questions.map((q) => ({
      questionId: q.questionId ?? null, // ✅ ส่ง id เดิมถ้ามี
      questionText: q.questionText,
      type: q.type,
      points: q.points ?? 1,
      choices:
        q.type === "multiple"
          ? q.options.map((text, idx) => ({
              choiceId: q.choiceIds?.[idx] ?? null, // ✅ ส่ง id เดิมถ้ามี
              text,
              correct: q.correctAnswers.includes(text),
            }))
          : [
              {
                text: q.correctAnswers[0] ?? "",
                correct: true,
              },
            ],
    }))
  )
);

3. เมื่อดึงข้อมูล quiz มาแก้ไข (หน้า Edit)

เวลาคุณโหลด lesson เพื่อแก้ไข quiz
อย่าลืม map ID เดิมใส่ใน form.questions เช่น
setForm({
  ...form,
  questions: lessonData.questions.map(q => ({
    questionId: q.questionId,
    questionText: q.questionText,
    type: q.type,
    points: q.points,
    options: q.choices?.map(c => c.text) || [],
    choiceIds: q.choices?.map(c => c.choiceId) || [],
    correctAnswers: q.choices?.filter(c => c.correct).map(c => c.text) || [],
  }))
});
