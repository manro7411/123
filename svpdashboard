package Testing;

import dto.CreateTeamRequestSimple;
import dto.Team.CreateMemberRequest;
import dto.Team.TeamSummary;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import model.MemberEntity;
import model.TeamEntity;

import java.net.URI;
import java.util.*;
import java.util.stream.Collectors;

@Path("/teams") // << ให้ตรงกับ frontend
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class TeamResource {

    @Inject
    EntityManager em;

    private static String genId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 21);
    }

    private static TeamSummary toSummary(TeamEntity team) {
        // supervisor = สมาชิกที่ role = "supervisor"
        String supervisorId = null;
        List<String> memberIds = new ArrayList<>();
        if (team.getMemberEntities() != null) {
            for (MemberEntity m : team.getMemberEntities()) {
                if (m == null) continue;
                if ("supervisor".equalsIgnoreCase(m.getRole())) {
                    supervisorId = m.getMemberId(); // เก็บเป็น userId/email ตามที่คุณใช้
                } else {
                    memberIds.add(m.getMemberId());
                }
            }
        }
        return new TeamSummary(team.getId(), team.getName(), supervisorId, memberIds);
    }

    // ---------- APIs ----------

    @GET
    public List<TeamSummary> getTeams() {
        List<TeamEntity> teams = em.createQuery(
                "SELECT DISTINCT t FROM TeamEntity t LEFT JOIN FETCH t.memberEntities",TeamEntity.class
        ).getResultList();
        return teams.stream().map(TeamResource::toSummary).toList();
    }

    @GET
    @Path("/{id}")
    public TeamSummary getTeam(@PathParam("id") String id) {
        TeamEntity team = em.find(TeamEntity.class, id);
        if (team == null) throw new NotFoundException("Team not found");
        // ensure members loaded
        team.getMemberEntities().size();
        return toSummary(team);
    }

    @GET
    @Path("/my-teams/{userId}")
    public List<TeamSummary> getTeamsByUserId(@PathParam("userId") String userId) {
        // เดิมใช้ m.userID แต่ใน create/set ใช้ userEmail -> ให้ใช้ userEmail ให้ตรงกัน
        List<TeamEntity> teams = em.createQuery(
                        "SELECT DISTINCT m.team FROM MemberEntity m " +
                                "LEFT JOIN FETCH m.team.memberEntities " +
                                "WHERE LOWER(m.userEmail) = LOWER(:userId)",
                        TeamEntity.class
                ).setParameter("userId", userId)
                .getResultList();

        return teams.stream().map(TeamResource::toSummary).toList();
    }

    @POST
    @Transactional
    public Response createTeam(CreateTeamRequestSimple request) {
        if (request == null || request.name == null || request.name.trim().isEmpty()) {
            throw new BadRequestException("Team name is required");
        }
        if (request.supervisorId == null || request.supervisorId.isBlank()) {
            throw new BadRequestException("supervisorId is required");
        }
        if (request.memberIds == null) {
            request.memberIds = List.of();
        }

        TeamEntity team = new TeamEntity();
        team.setId(genId());
        team.setName(request.name.trim());
        team.setDescription(request.description); // optional
        team.setCreateBy(request.createBy);       // optional
        team.setJoinCode(String.format("%06d", new Random().nextInt(1_000_000)));

        // เตรียมสมาชิก: ใส่ supervisor เป็นสมาชิกด้วย role = "supervisor"
        List<MemberEntity> members = new ArrayList<>();

        MemberEntity sup = new MemberEntity();
        sup.setId(genId());
        sup.setTeam(team);
        sup.setMemberId(request.supervisorId); // ใช้เป็น userId/email ให้สอดคล้องกับ frontend
        sup.setRole("supervisor");
        sup.setNameMembers(request.supervisorId); // ถ้ายังไม่มีชื่อจริง ใช้รหัสแทนไปก่อน
        members.add(sup);

        // ใส่สมาชิกทีมทั่วไป
        for (String mid : request.memberIds.stream().filter(Objects::nonNull).collect(Collectors.toSet())) {
            MemberEntity m = new MemberEntity();
            m.setId(genId());
            m.setTeam(team);
            m.setMemberId(mid);
            m.setRole("member");
            m.setNameMembers(mid); // ถ้ามีชื่อจริง ค่อยอัปเดตภายหลัง
            members.add(m);
        }

        team.setMemberEntities(members);
        em.persist(team);

        return Response.created(URI.create("/api/teams/" + team.getId()))
                .entity(toSummary(team))
                .build();
    }

    @PUT
    @Path("/{id}")
    @Transactional
    public Response updateTeam(@PathParam("id") String id, TeamEntity updatedTeam) {
        TeamEntity team = em.find(TeamEntity.class, id);
        if (team == null) throw new NotFoundException("Team not found");

        if (updatedTeam.getName() != null) {
            team.setName(updatedTeam.getName());
        }
        if (updatedTeam.getDescription() != null) {
            team.setDescription(updatedTeam.getDescription());
        }

        // ส่งกลับเป็น TeamSummary เพื่อให้ frontend ใช้รูปแบบเดียวกัน
        team.getMemberEntities().size();
        return Response.ok(toSummary(team)).build();
    }

    @DELETE
    @Path("/{id}")
    @Transactional
    public Response deleteTeam(@PathParam("id") String id) {
        TeamEntity team = em.find(TeamEntity.class, id);
        if (team == null) throw new NotFoundException("Team not found");
        em.remove(team);
        return Response.noContent().build();
    }

    // -------- keep your existing join by code but align field names --------
    @POST
    @Path("/joining")
    @Transactional
    public Response joinTeamByCode(CreateMemberRequest request) {
        if (request == null || request.joinCode == null || request.joinCode.trim().length() != 6) {
            throw new BadRequestException("Join code is invalid");
        }

        List<TeamEntity> teams = em.createQuery(
                "SELECT DISTINCT t FROM TeamEntity t LEFT JOIN FETCH t.memberEntities WHERE t.joinCode = :joinCode",
                TeamEntity.class
        ).setParameter("joinCode", request.joinCode).getResultList();

        if (teams.isEmpty()) {
            throw new BadRequestException("Join code is invalid");
        }

        TeamEntity team = teams.get(0);

        boolean alreadyExists = team.getMemberEntities()
                .stream()
                .anyMatch(member -> member.getMemberId() != null &&
                        member.getMemberId().equalsIgnoreCase(request.userId));

        if (alreadyExists) {
            throw new WebApplicationException("User already in the team", 409);
        }

        MemberEntity member = new MemberEntity();
        member.setId(genId());
        member.setTeam(team);
        member.setMemberId(request.userId);
        member.setRole(Optional.ofNullable(request.getRole()).orElse("member"));
        member.setNameMembers(Optional.ofNullable(request.userName).orElse(request.userId));
        team.getMemberEntities().add(member);

        em.persist(member);
        return Response.ok().entity(toSummary(team)).build();
    }
}

package Testing;

import dto.Team.CreateMemberRequest;
import dto.Team.TeamMemberDTO;
import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;
import model.MemberEntity;
import model.TeamEntity;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Path("/teams/{teamId}/members")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class TeamMemberResource {
    public static final Logger log = LoggerFactory.getLogger(TeamMemberResource.class);

    @Inject
    EntityManager em;


    @GET
    @RolesAllowed({"admin","supervisor","administrator"})
    public List<TeamMemberDTO> listMembers(@PathParam("teamId") String teamId , @QueryParam("order") @DefaultValue("default") String order) {
        log.info("Start: Listing members for team ID: {} with order: {}", teamId, order);
        TeamEntity team = em.find(TeamEntity.class, teamId);
        if (team == null) {
            log.warn("Team with ID {} not found", teamId);
            throw new WebApplicationException("Team not found", 404);
        }
        String jpql = "SELECT m FROM MemberEntity m WHERE m.team.id = :tid";
        if ("roleThenJoined".equalsIgnoreCase(order)) {
            // supervisor -> member -> others, then joinedAt ASC
            jpql += " ORDER BY " +
                    "CASE WHEN LOWER(m.role)='supervisor' THEN 1 " +
                    "     WHEN LOWER(m.role)='member' THEN 2 " +
                    "     ELSE 3 END, m.joinedAt ASC";
        } else {
            jpql += " ORDER BY m.joinedAt ASC";
        }
        List<MemberEntity> members = em.createQuery(jpql, MemberEntity.class)
                .setParameter("tid", teamId).getResultList();

        return members.stream()
                .map(m -> new TeamMemberDTO(m.getMemberId(), m.getNameMembers(), m.getRole()))
                .collect(Collectors.toList());
    }

    @POST
    @Transactional
    @RolesAllowed({"admin","supervisor","administrator"})

    public Response addMember(@PathParam("teamId") String teamId, CreateMemberRequest request, @Context SecurityContext securityContext) {
        String currentUser = securityContext.getUserPrincipal().getName();
        log.info("User {} is adding a member to team {}", currentUser, teamId);
        TeamEntity team = em.find(TeamEntity.class, teamId);
        if (team == null) {
            log.warn("Team with ID : {} not found", teamId);
            throw new WebApplicationException("Team not found", 404);
        }
        MemberEntity member = new MemberEntity();
        member.setId(UUID.randomUUID().toString().replace("-", "").substring(0, 21));
        member.setTeam(team);
        member.setMemberId(request.userId);
        member.setRole(request.role != null ? request.role : "member");
        em.persist(member);
        log.info("Member {} added to team {} by user {}", member.getMemberId(), teamId, currentUser);
        return Response.ok(member).build();
    }

    @DELETE
    @Path("/{memberId}")
    @Transactional
    public void deleteMember(@PathParam("teamId") String teamId, @PathParam("memberId") String memberId,@Context SecurityContext securityContext) {
        String currentUser = securityContext.getUserPrincipal().getName();
        log.info("User {} is deleting member {} from team {}", currentUser, memberId, teamId);
        MemberEntity member = em.find(MemberEntity.class, memberId);
        if (member != null && member.getTeam().getId().equals(teamId)) {
            log.info("Member {} found in team {}, proceeding to delete", memberId, teamId);
            em.remove(member);
        } else {
            log.error("Member {} not found in team {}", memberId, teamId);
            throw new WebApplicationException("Member not found", 404);
        }
    }

    @PUT
    @Transactional
    @Path("/{memberId}/role")
    public Response setRole(@PathParam("teamId") String teamId, @PathParam("memberId") String memberId,
                            java.util.Map<String,String> body,@Context SecurityContext securityContext) {
        String currentUser = securityContext.getUserPrincipal().getName();
        String role = body != null ? body.getOrDefault("role", "").toLowerCase() : "";
        if (!role.equals("user") && !role.equals("member") && !role.equals("admin") && !role.equals("supervisor")) {
            log.warn("Invalid role value: {} -> role must be member or trainer " , role);
            throw new BadRequestException("role must be 'member' or 'trainer'");
        }
        MemberEntity m = em.createQuery(
                        "SELECT m FROM MemberEntity m WHERE m.team.id = :tid AND LOWER(m.memberId) = LOWER(:uid)",
                        MemberEntity.class
                ).setParameter("tid", teamId).setParameter("uid", memberId).getResultStream().findFirst()
                .orElseThrow(() -> new NotFoundException("Member not found"));
        if ("supervisor".equalsIgnoreCase(m.getRole()) && !"supervisor".equalsIgnoreCase(role)) {
            long supervisorCount = em.createQuery(
                            "SELECT COUNT(m) FROM MemberEntity m WHERE m.team.id = :tid AND LOWER(m.role) = 'supervisor'",
                            Long.class)
                    .setParameter("tid", teamId)
                    .getSingleResult();
            if (supervisorCount <= 1) {
                log.warn("Cannot change role of the last supervisor in team {}", teamId);
                throw new BadRequestException("Cannot change role of the last supervisor in the team");
            }
        }
        m.setRole(role);
        em.merge(m);
        log.info("User {} changed role of member {} in team {} to {}", currentUser, memberId, teamId, role);
        return Response.ok(new TeamMemberDTO(m.getMemberId(), m.getNameMembers(), m.getRole())).build();
    }


}
