package Testing;

import dto.ProfileDto;
import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import model.User;
import org.eclipse.microprofile.jwt.JsonWebToken;
import org.jboss.resteasy.reactive.PartType;
import org.mindrot.jbcrypt.BCrypt;
import org.slf4j.*;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.*;
import java.util.List;
import java.util.stream.Stream;

@Path("/api/profile")
@Produces(MediaType.APPLICATION_JSON)
public class ProfileResource {

    private static final Logger log = LoggerFactory.getLogger(ProfileResource.class);
    @Inject EntityManager em;
    @Inject JsonWebToken jwt;

    // สำหรับ FE รุ่นใหม่เรียก /api/profile/me
    @GET
    @Path("/me")
    @RolesAllowed({"user", "employee", "admin", "supervisor", "administrator"})
    public ProfileDto getMeModern(@Context SecurityContext ctx) {
        return getMe(ctx);
    }

    // รองรับโค้ดเก่า /api/profile
    @GET
    @RolesAllowed({"user", "employee", "admin", "supervisor", "administrator"})
    public ProfileDto getMe(@Context SecurityContext securityContext) {
        String currentUser = securityContext.getUserPrincipal().getName();
        log.info("User {} is retrieving their profile", currentUser);
        String email = jwt.getClaim("email");

        User user = em.createQuery(
                "SELECT u FROM User u WHERE u.email = :email", User.class)
            .setParameter("email", email)
            .getSingleResult();

        return new ProfileDto(
                user.getId().toString(),
                user.getName(),
                user.getEmail(),
                user.getAvatar(),
                user.isLdap()
        );
    }

    @PUT
    @Path("/")
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Transactional
    @RolesAllowed({"user","employee","admin","supervisor","administrator"})
    public ProfileDto updateMe(
            @BeanParam UpdateDto dto,
            @Context SecurityContext securityContext
    ) {
        String currentUser = securityContext.getUserPrincipal().getName();
        log.info("User {} is updating their profile", currentUser);
        String email = jwt.getClaim("email");

        User user = em.createQuery(
                "SELECT u FROM User u WHERE u.email = :email", User.class)
            .setParameter("email", email)
            .getSingleResult();

        if (dto.name != null && !dto.name.isBlank()) user.setName(dto.name);
        if (dto.email != null && !dto.email.isBlank()) user.setEmail(dto.email);
        if (dto.password != null && !dto.password.isBlank()) {
            user.setPassword(BCrypt.hashpw(dto.password, BCrypt.gensalt(12)));
        }

        if (dto.profilePicture != null) {
            try {
                String filename = "avatar_" + user.getId() + ".jpg";
                Path dir = Paths.get("uploads/avatars");
                Files.createDirectories(dir);
                Path path = dir.resolve(filename);
                Files.copy(dto.profilePicture, path, StandardCopyOption.REPLACE_EXISTING);
                user.setAvatar("uploads/avatars/" + filename);
            } catch (Exception e) {
                throw new InternalServerErrorException("Failed to save avatar");
            }
        }
        return new ProfileDto(user.getId().toString(), user.getName(), user.getEmail(), user.getAvatar());
    }

    @GET
    @Path("/avatars/{filename}")
    @Produces({"image/jpeg","image/png","image/webp"})
    public Response getAvatar(@PathParam("filename") String filename) {
        Path path = Paths.get("uploads/avatars/" + filename);
        if (!Files.exists(path)) return Response.status(Response.Status.NOT_FOUND).build();
        try { return Response.ok(Files.newInputStream(path)).build(); }
        catch (IOException e){ return Response.serverError().entity(e.getMessage()).build(); }
    }

    @GET
    @Path("/users")
    @RolesAllowed({"admin","supervisor","administrator"})
    public List<ProfileDto> getAllUsers() {
        return em.createQuery("SELECT u FROM User u", User.class)
                .getResultList()
                .stream()
                .map(u -> new ProfileDto(u.getId().toString(), u.getName(), u.getEmail(), u.getAvatar()))
                .toList();
    }

    @GET
    @Path("/users/for-supervisor")
    @RolesAllowed({"supervisor","administrator"})
    public List<UserWithRoleDto> getUsersForSupervisor() {
        List<User> users = em.createQuery(
                "SELECT u FROM User u WHERE LOWER(u.role) <> 'administrator'", User.class)
            .getResultList();
        return users.stream()
                .map(u -> new UserWithRoleDto(
                        u.getId().toString(), u.getName(), u.getEmail(),
                        u.getRole() == null ? "user" : u.getRole(), u.isLdap()))
                .toList();
    }

    @PUT
    @Path("/users/{id}/role")
    @Transactional
    @RolesAllowed({"supervisor","administrator"})
    public String updateUserRole(@PathParam("id") String userId, RoleUpdateDto dto) {
        User user = em.find(User.class, userId);
        if (user == null) throw new NotFoundException("User not found");
        if (!isValidRole(dto.role)) throw new BadRequestException("Invalid role specified");
        user.setRole(dto.role);
        return "Role of user " + (user.getName()==null?user.getEmail():user.getName()) + " updated to " + dto.role;
    }

    private boolean isValidRole(String role) {
        return Stream.of("user","employee","admin","supervisor","administrator")
                .anyMatch(r -> r.equalsIgnoreCase(role));
    }

    public static class UserWithRoleDto {
        public String id; public String name; public String email; public String role; public Boolean isLdap;
        public UserWithRoleDto() {}
        public UserWithRoleDto(String id,String name,String email,String role,Boolean isLdap){
            this.id=id; this.name=name; this.email=email; this.role=role; this.isLdap=isLdap;
        }
    }

    public static class RoleUpdateDto {
        public String role;
    }

    public static class UpdateDto {
        @FormParam("name") @PartType("text/plain") public String name;
        @FormParam("email") @PartType("text/plain") public String email;
        @FormParam("password") @PartType("text/plain") public String password;
        @FormParam("profilePicture") @PartType("application/octet-stream") public InputStream profilePicture;
    }
}


-----------------------------------------------------------
package Testing;

import dto.CreateTeamRequestSimple;
import dto.Team.CreateMemberRequest;
import dto.Team.TeamSummary;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import model.MemberEntity;
import model.TeamEntity;
import org.slf4j.*;

import java.net.URI;
import java.util.*;
import java.util.stream.Collectors;

@Path("/api/teams")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class TeamResource {
    private static final Logger log = LoggerFactory.getLogger(TeamResource.class);

    @Inject EntityManager em;

    private static String genId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 21);
    }

    private static TeamSummary toSummary(TeamEntity team) {
        String supervisorId = null;
        List<String> memberIds = new ArrayList<>();
        if (team.getMemberEntities() != null) {
            for (MemberEntity m : team.getMemberEntities()) {
                if (m == null) continue;
                if ("supervisor".equalsIgnoreCase(m.getRole())) supervisorId = m.getMemberId();
                else memberIds.add(m.getMemberId());
            }
        }
        return new TeamSummary(team.getId(), team.getName(), supervisorId, memberIds);
    }

    @GET
    public List<TeamSummary> getTeams() {
        List<TeamEntity> teams = em.createQuery(
                "SELECT DISTINCT t FROM TeamEntity t LEFT JOIN FETCH t.memberEntities", TeamEntity.class
        ).getResultList();
        return teams.stream().map(TeamResource::toSummary).toList();
    }

    @GET @Path("/{id}")
    public TeamSummary getTeam(@PathParam("id") String id) {
        TeamEntity team = em.find(TeamEntity.class, id);
        if (team == null) throw new NotFoundException("Team not found");
        team.getMemberEntities().size(); // force load
        return toSummary(team);
    }

    // FE ใช้แบบ query param: /api/teams/my-teams?userId=...
    @GET @Path("/my-teams")
    public List<TeamSummary> getTeamsByQueryUserId(@QueryParam("userId") String userId) {
        if (userId == null || userId.isBlank()) throw new BadRequestException("userId query parameter is required");
        List<TeamEntity> teams = em.createQuery(
                        "SELECT DISTINCT m.team FROM MemberEntity m " +
                                "LEFT JOIN FETCH m.team.memberEntities " +
                                "WHERE LOWER(m.memberId) = LOWER(:uid)",
                        TeamEntity.class)
                .setParameter("uid", userId).getResultList();
        return teams.stream().map(TeamResource::toSummary).toList();
    }

    // สำรอง: /api/teams/my-teams/{userId}
    @GET @Path("/my-teams/{userId}")
    public List<TeamSummary> getTeamsByUserId(@PathParam("userId") String userId) {
        return getTeamsByQueryUserId(userId);
    }

    @POST
    @Transactional
    public Response createTeam(CreateTeamRequestSimple request, @Context SecurityContext securityContext) {
        if (request == null || request.name == null || request.name.isBlank())
            throw new BadRequestException("Team name is required");
        if (request.supervisorId == null || request.supervisorId.isBlank())
            throw new BadRequestException("supervisorId is required");
        if (request.memberIds == null) request.memberIds = List.of();

        TeamEntity team = new TeamEntity();
        team.setId(genId());
        team.setName(request.name.trim());
        team.setDescription(request.description);
        team.setCreateBy(request.createBy);
        team.setJoinCode(String.format("%06d", new Random().nextInt(1_000_000)));

        List<MemberEntity> members = new ArrayList<>();
        MemberEntity sup = new MemberEntity();
        sup.setId(genId());
        sup.setTeam(team);
        sup.setMemberId(request.supervisorId);
        sup.setRole("supervisor");
        sup.setNameMembers(request.supervisorId);
        members.add(sup);

        for (String mid : request.memberIds.stream().filter(Objects::nonNull).collect(Collectors.toSet())) {
            if (mid.equalsIgnoreCase(request.supervisorId)) continue;
            MemberEntity m = new MemberEntity();
            m.setId(genId());
            m.setTeam(team);
            m.setMemberId(mid);
            m.setRole("member");
            m.setNameMembers(mid);
            members.add(m);
        }

        team.setMemberEntities(members);
        em.persist(team);

        return Response.created(URI.create("/api/teams/" + team.getId()))
                .entity(toSummary(team))
                .build();
    }

    @PUT @Path("/{id}")
    @Transactional
    public Response updateTeam(@PathParam("id") String id, TeamEntity updatedTeam) {
        TeamEntity team = em.find(TeamEntity.class, id);
        if (team == null) throw new NotFoundException("Team not found");
        if (updatedTeam.getName() != null) team.setName(updatedTeam.getName());
        if (updatedTeam.getDescription() != null) team.setDescription(updatedTeam.getDescription());
        team.getMemberEntities().size();
        return Response.ok(toSummary(team)).build();
    }

    @DELETE @Path("/{id}")
    @Transactional
    public Response deleteTeam(@PathParam("id") String id) {
        TeamEntity team = em.find(TeamEntity.class, id);
        if (team == null) throw new NotFoundException("Team not found");
        em.remove(team);
        return Response.noContent().build();
    }

    @POST @Path("/joining")
    @Transactional
    public Response joinTeamByCode(CreateMemberRequest request) {
        if (request == null || request.joinCode == null || request.joinCode.trim().length() != 6)
            throw new BadRequestException("Join code is invalid");

        List<TeamEntity> teams = em.createQuery(
                        "SELECT DISTINCT t FROM TeamEntity t LEFT JOIN FETCH t.memberEntities WHERE t.joinCode = :joinCode",
                        TeamEntity.class)
                .setParameter("joinCode", request.joinCode).getResultList();
        if (teams.isEmpty()) throw new BadRequestException("Join code is invalid");

        TeamEntity team = teams.get(0);
        boolean alreadyExists = team.getMemberEntities().stream()
                .anyMatch(member -> member.getMemberId() != null &&
                        member.getMemberId().equalsIgnoreCase(request.userId));
        if (alreadyExists) throw new WebApplicationException("User already in the team", 409);

        MemberEntity member = new MemberEntity();
        member.setId(genId());
        member.setTeam(team);
        member.setMemberId(request.userId);
        member.setRole(Optional.ofNullable(request.getRole()).orElse("member"));
        member.setNameMembers(Optional.ofNullable(request.userName).orElse(request.userId));
        team.getMemberEntities().add(member);
        em.persist(member);

        return Response.ok(toSummary(team)).build();
    }
}
------------
package Testing;

import dto.Team.CreateMemberRequest;
import dto.Team.TeamMemberDTO;
import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import model.MemberEntity;
import model.TeamEntity;
import org.slf4j.*;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Path("/api/teams/{teamId}/members")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class TeamMemberResource {
    public static final Logger log = LoggerFactory.getLogger(TeamMemberResource.class);

    @Inject EntityManager em;

    @GET
    @RolesAllowed({"admin","supervisor","administrator"})
    public List<TeamMemberDTO> listMembers(@PathParam("teamId") String teamId,
                                           @QueryParam("order") @DefaultValue("default") String order) {
        TeamEntity team = em.find(TeamEntity.class, teamId);
        if (team == null) throw new WebApplicationException("Team not found", 404);

        String jpql = "SELECT m FROM MemberEntity m WHERE m.team.id = :tid";
        if ("roleThenJoined".equalsIgnoreCase(order)) {
            jpql += " ORDER BY CASE WHEN LOWER(m.role)='supervisor' THEN 1 " +
                    "WHEN LOWER(m.role)='member' THEN 2 ELSE 3 END, m.joinedAt ASC";
        } else {
            jpql += " ORDER BY m.joinedAt ASC";
        }

        List<MemberEntity> members = em.createQuery(jpql, MemberEntity.class)
                .setParameter("tid", teamId).getResultList();

        return members.stream()
                .map(m -> new TeamMemberDTO(m.getMemberId(), m.getNameMembers(), m.getRole()))
                .collect(Collectors.toList());
    }

    @POST
    @Transactional
    @RolesAllowed({"admin","supervisor","administrator"})
    public Response addMember(@PathParam("teamId") String teamId,
                              CreateMemberRequest request,
                              @Context SecurityContext securityContext) {
        TeamEntity team = em.find(TeamEntity.class, teamId);
        if (team == null) throw new WebApplicationException("Team not found", 404);

        MemberEntity member = new MemberEntity();
        member.setId(UUID.randomUUID().toString().replace("-", "").substring(0, 21));
        member.setTeam(team);
        member.setMemberId(request.userId);
        member.setNameMembers(request.userName != null ? request.userName : request.userId);
        member.setRole(request.role != null ? request.role : "member");
        em.persist(member);
        return Response.ok(new TeamMemberDTO(member.getMemberId(), member.getNameMembers(), member.getRole())).build();
    }

    @DELETE
    @Path("/{memberId}")
    @Transactional
    @RolesAllowed({"admin","supervisor","administrator"})
    public void deleteMember(@PathParam("teamId") String teamId, @PathParam("memberId") String memberId) {
        MemberEntity member = em.find(MemberEntity.class, memberId);
        if (member != null && member.getTeam().getId().equals(teamId)) em.remove(member);
        else throw new WebApplicationException("Member not found", 404);
    }

    // ใช้ในหน้าซุป: ตั้ง/ถอน trainer
    @PUT
    @Transactional
    @Path("/{memberId}/role")
    @RolesAllowed({"admin","supervisor","administrator"})
    public Response setRole(@PathParam("teamId") String teamId,
                            @PathParam("memberId") String memberId,
                            java.util.Map<String,String> body) {
        String role = body != null ? body.getOrDefault("role","").toLowerCase() : "";
        if (!role.equals("member") && !role.equals("trainer"))
            throw new BadRequestException("role must be 'member' or 'trainer'");

        MemberEntity m = em.createQuery(
                        "SELECT m FROM MemberEntity m WHERE m.team.id = :tid AND LOWER(m.memberId) = LOWER(:uid)",
                        MemberEntity.class)
                .setParameter("tid", teamId)
                .setParameter("uid", memberId)
                .getResultStream().findFirst()
                .orElseThrow(() -> new NotFoundException("Member not found"));

        if ("supervisor".equalsIgnoreCase(m.getRole()))
            throw new BadRequestException("Use /api/admin/teams/{teamId}/supervisor to change supervisor");

        m.setRole(role);
        em.merge(m);
        return Response.ok(new TeamMemberDTO(m.getMemberId(), m.getNameMembers(), m.getRole())).build();
    }
}
------------------------------
package Testing;

import dto.Team.*;
import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import model.MemberEntity;
import model.TeamEntity;
import org.slf4j.*;

import java.net.URI;
import java.util.*;
import java.util.stream.Collectors;

@Path("/api/admin/teams")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class TeamAdminResource {

    private static final Logger log = LoggerFactory.getLogger(TeamAdminResource.class);
    public static final String ROLE_ADMINISTRATOR = "administrator";

    @Inject EntityManager em;

    private static String genId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 21);
    }

    private static TeamSummary toSummary(TeamEntity team) {
        String supervisorId = null;
        List<String> memberIds = new ArrayList<>();
        if (team.getMemberEntities() != null) {
            for (MemberEntity m : team.getMemberEntities()) {
                if (m == null) continue;
                if ("supervisor".equalsIgnoreCase(m.getRole())) supervisorId = m.getMemberId();
                else memberIds.add(m.getMemberId());
            }
        }
        return new TeamSummary(team.getId(), team.getName(), supervisorId, memberIds);
    }

    // Optional: ให้หน้าแอดมินดึงทีมทั้งหมด
    @GET
    @RolesAllowed(ROLE_ADMINISTRATOR)
    public List<TeamSummary> listAll() {
        return em.createQuery(
                        "SELECT DISTINCT t FROM TeamEntity t LEFT JOIN FETCH t.memberEntities",
                        TeamEntity.class)
                .getResultList()
                .stream().map(TeamAdminResource::toSummary).toList();
    }

    @POST
    @Transactional
    @RolesAllowed(ROLE_ADMINISTRATOR)
    public Response createTeam(CreateTeamRequestAdmin req, @Context SecurityContext sc) {
        if (req == null || req.name == null || req.name.isBlank())
            throw new BadRequestException("Team name is required");
        if (req.supervisorId == null || req.supervisorId.isBlank())
            throw new BadRequestException("supervisorId is required");

        TeamEntity duplicate = em.createQuery(
                        "SELECT t FROM TeamEntity t WHERE LOWER(t.name)=:n", TeamEntity.class)
                .setParameter("n", req.name.trim().toLowerCase())
                .getResultStream().findFirst().orElse(null);
        if (duplicate != null) return Response.status(Response.Status.CONFLICT).entity("Team name already exists").build();

        TeamEntity team = new TeamEntity();
        team.setId(genId());
        team.setName(req.name.trim());
        team.setDescription(req.description);
        team.setCreateBy(req.createBy);

        List<MemberEntity> members = new ArrayList<>();
        MemberEntity sup = new MemberEntity();
        sup.setId(genId());
        sup.setTeam(team);
        sup.setMemberId(req.supervisorId);
        sup.setNameMembers(req.supervisorName != null ? req.supervisorName : req.supervisorId);
        sup.setRole("supervisor");
        members.add(sup);

        if (req.members != null) {
            for (CreateMemberRequest mreq : req.members) {
                if (mreq == null || mreq.userId == null || mreq.userId.isBlank()) continue;
                if (req.supervisorId.equalsIgnoreCase(mreq.userId)) continue;
                MemberEntity m = new MemberEntity();
                m.setId(genId());
                m.setTeam(team);
                m.setMemberId(mreq.userId);
                m.setNameMembers(mreq.userName != null ? mreq.userName : mreq.userId);
                m.setRole((mreq.role != null && !"supervisor".equalsIgnoreCase(mreq.role)) ? mreq.role : "member");
                members.add(m);
            }
        }
        team.setMemberEntities(members);
        em.persist(team);

        return Response.created(URI.create("/api/teams/" + team.getId()))
                .entity(toSummary(team)).build();
    }

    @POST
    @Path("/{teamId}/members")
    @Transactional
    @RolesAllowed(ROLE_ADMINISTRATOR)
    public Response addMembers(@PathParam("teamId") String teamId, AddMemberRequest req) {
        TeamEntity team = em.find(TeamEntity.class, teamId);
        if (team == null) throw new NotFoundException("Team not found");
        team.getMemberEntities().size();

        if (req == null || req.members == null || req.members.isEmpty())
            throw new BadRequestException("members are required");

        Set<String> existing = team.getMemberEntities().stream()
                .map(m -> m.getMemberId().toLowerCase()).collect(Collectors.toSet());

        List<MemberEntity> newOnes = new ArrayList<>();
        for (CreateMemberRequest mreq : req.members) {
            if (mreq == null || mreq.userId == null || mreq.userId.isBlank()) continue;
            String uid = mreq.userId.toLowerCase();
            if (existing.contains(uid)) continue;

            MemberEntity m = new MemberEntity();
            m.setId(genId());
            m.setTeam(team);
            m.setMemberId(mreq.userId);
            m.setNameMembers(mreq.userName != null ? mreq.userName : mreq.userId);
            String role = (mreq.role != null && !"supervisor".equalsIgnoreCase(mreq.role)) ? mreq.role : "member";
            m.setRole(role);
            newOnes.add(m);
            existing.add(uid);
        }

        for (MemberEntity m : newOnes) em.persist(m);

        List<TeamMemberDTO> dto = em.createQuery(
                        "SELECT m FROM MemberEntity m WHERE m.team.id = :tid ORDER BY m.joinedAt ASC",
                        MemberEntity.class)
                .setParameter("tid", teamId).getResultList()
                .stream().map(m -> new TeamMemberDTO(m.getMemberId(), m.getNameMembers(), m.getRole()))
                .toList();
        return Response.ok(dto).build();
    }

    @PUT
    @Path("/{teamId}/supervisor")
    @RolesAllowed(ROLE_ADMINISTRATOR)
    @Transactional
    public Response setSupervisor(@PathParam("teamId") String teamId, SetSupervisorRequest req) {
        if (req == null || req.supervisorId == null || req.supervisorId.isBlank())
            throw new BadRequestException("supervisorId is required");

        TeamEntity team = em.find(TeamEntity.class, teamId);
        if (team == null) throw new NotFoundException("Team not found");
        team.getMemberEntities().size();

        MemberEntity currentSup = team.getMemberEntities().stream()
                .filter(m -> "supervisor".equalsIgnoreCase(m.getRole()))
                .findFirst().orElse(null);

        MemberEntity newSup = team.getMemberEntities().stream()
                .filter(m -> m.getMemberId().equalsIgnoreCase(req.supervisorId))
                .findFirst().orElse(null);

        if (newSup != null) {
            newSup.setRole("supervisor");
            if (req.supervisorName != null && !req.supervisorName.isBlank())
                newSup.setNameMembers(req.supervisorName);
            em.merge(newSup);
        } else {
            newSup = new MemberEntity();
            newSup.setId(genId());
            newSup.setTeam(team);
            newSup.setMemberId(req.supervisorId);
            newSup.setNameMembers(req.supervisorName != null ? req.supervisorName : req.supervisorId);
            newSup.setRole("supervisor");
            em.persist(newSup);
        }

        if (currentSup != null && !currentSup.getMemberId().equalsIgnoreCase(newSup.getMemberId())) {
            currentSup.setRole("member");
            em.merge(currentSup);
        }

        List<TeamMemberDTO> dto = em.createQuery(
                        "SELECT m FROM MemberEntity m WHERE m.team.id = :tid ORDER BY m.joinedAt ASC",
                        MemberEntity.class)
                .setParameter("tid", teamId).getResultList()
                .stream().map(m -> new TeamMemberDTO(m.getMemberId(), m.getNameMembers(), m.getRole()))
                .toList();
        return Response.ok(dto).build();
    }
}
import { useEffect, useMemo, useState } from "react";
import axios from "axios";
import SupervisorSidebarWidget from "./Widgets/SupervisorSideBar";
import { ChevronRight, Shield, Users, X, Search } from "lucide-react";

// ---------------------- Axios ----------------------
const axiosClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || "/",
});
axiosClient.interceptors.request.use((config) => {
  const token = localStorage.getItem("token") || sessionStorage.getItem("token");
  if (token) {
    config.headers = { ...(config.headers || {}), Authorization: `Bearer ${token}` };
  }
  return config;
});

// ---------------------- Types ----------------------
export type Team = { id: string; name: string; supervisorId?: string | null; memberIds?: string[] };
export type TeamMember = { userId: string; name?: string; role: "member" | "trainer" | "supervisor" };

// ---------------------- Small UI ----------------------
function Chip({ children, onRemove }:{children: React.ReactNode; onRemove?:()=>void}){
  return (
    <span className="inline-flex items-center gap-1 rounded-full border px-3 py-1 text-xs bg-white">
      {children}
      {onRemove && (
        <button className="opacity-60 hover:opacity-100" onClick={onRemove}>
          <X className="w-3.5 h-3.5" />
        </button>
      )}
    </span>
  );
}

// ---------------------- Members Panel ----------------------
function TeamMembersManager({ teamId, canManage }: { teamId: string; canManage: boolean; }) {
  const [members, setMembers] = useState<TeamMember[]>([]);
  const [selected, setSelected] = useState<TeamMember | null>(null);
  const [search, setSearch] = useState("");
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState<string | null>(null);

  const fetchMembers = async () => {
    setLoading(true);
    try {
      const { data } = await axiosClient.get<TeamMember[]>(`/api/teams/${teamId}/members`, {
        params: { order: "roleThenJoined" },
      });
      setMembers(data || []);
      setSelected(prev => prev ? data.find(d => d.userId === prev.userId) ?? data[0] ?? null : data[0] ?? null);
      setErr(null);
    } catch (e: any) {
      console.error(e);
      setErr(e?.response?.data?.message || "โหลดสมาชิกทีมไม่สำเร็จ");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => { fetchMembers(); /* eslint-disable-next-line react-hooks/exhaustive-deps */ }, [teamId]);

  const setTrainer = async (userId: string, nextRole: "trainer" | "member") => {
    if (!canManage) return;
    try {
      await axiosClient.put(`/api/teams/${teamId}/members/${encodeURIComponent(userId)}/role`, { role: nextRole });
      await fetchMembers();
    } catch (e: any) {
      alert(e?.response?.data?.message || "อัปเดตบทบาทในทีมไม่สำเร็จ");
    }
  };

  const list = useMemo(() => {
    const q = search.trim().toLowerCase();
    if (!q) return members;
    return members.filter(m => (m.name||"").toLowerCase().includes(q) || m.userId.toLowerCase().includes(q));
  }, [members, search]);

  if (loading) return <div className="text-sm opacity-70">กำลังโหลดสมาชิกทีม...</div>;
  if (err) return <div className="text-sm text-red-600">{err}</div>;

  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      {/* Left: list */}
      <div className="md:col-span-1 rounded-2xl border bg-white/60 overflow-hidden">
        <div className="px-4 py-3 border-b font-semibold flex items-center justify-between">
          <span>สมาชิกทีม</span>
          <span className="text-xs opacity-70">{members.length} คน</span>
        </div>
        <div className="p-3 border-b bg-white">
          <div className="relative">
            <Search className="w-4 h-4 absolute left-3 top-1/2 -translate-y-1/2 opacity-60" />
            <input
              className="w-full rounded-xl border pl-9 pr-3 py-2 bg-white"
              placeholder="ค้นหาชื่อหรืออีเมล"
              value={search}
              onChange={(e)=>setSearch(e.target.value)}
            />
          </div>
        </div>
        <div className="max-h-96 overflow-auto divide-y">
          {list.map(m => (
            <button
              key={`${teamId}-${m.userId}`}
              onClick={()=>setSelected(m)}
              className={`w-full text-left p-3 hover:bg-gray-50 flex items-center justify-between ${selected?.userId===m.userId?'bg-gray-50':''}`}
            >
              <div className="min-w-0">
                <div className="font-medium truncate">{m.name || m.userId}</div>
                <div className="text-xs opacity-70">บทบาทในทีม: {m.role}</div>
              </div>
              <ChevronRight className="w-4 h-4 opacity-60"/>
            </button>
          ))}
        </div>
      </div>

      {/* Right: detail */}
      <div className="md:col-span-2 rounded-2xl border bg-white/60 p-4">
        {selected ? (
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <div>
                <div className="text-lg font-semibold">{selected.name || selected.userId}</div>
                <div className="text-sm opacity-70">บทบาทในทีมปัจจุบัน: {selected.role}</div>
              </div>
              <div className="flex gap-2">
                <Chip><Users className="w-3.5 h-3.5"/> {selected.userId}</Chip>
                {selected.role==='trainer' && (
                  <Chip><Shield className="w-3.5 h-3.5"/> trainer</Chip>
                )}
              </div>
            </div>

            {canManage && selected.role !== 'supervisor' && (
              <div className="flex gap-2">
                {selected.role !== 'trainer' ? (
                  <button className="rounded-xl px-4 py-2 border bg-white hover:bg-gray-50"
                          onClick={()=>setTrainer(selected.userId,'trainer')}>
                    ตั้งเป็น Trainer (สร้างคอร์สได้)
                  </button>
                ) : (
                  <button className="rounded-xl px-4 py-2 border bg-white hover:bg-gray-50"
                          onClick={()=>setTrainer(selected.userId,'member')}>
                    ถอนบทบาท Trainer
                  </button>
                )}
              </div>
            )}

            <div className="text-sm opacity-70">
              *บทบาท “trainer” จะทำให้สมาชิกสร้าง/จัดการคอร์สของทีมได้
            </div>
          </div>
        ) : (
          <div className="text-sm opacity-70">เลือกสมาชิกทางซ้ายเพื่อดูรายละเอียด</div>
        )}
      </div>
    </div>
  );
}

// ---------------------- Main ----------------------
export default function SupervisorDashboard(){
  const [teams, setTeams] = useState<Team[]>([]);
  const [selectedTeamId, setSelectedTeamId] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState<string | null>(null);

  const parseJwt = (token: string | null): any | null => {
    if (!token) return null;
    const parts = token.split(".");
    if (parts.length !== 3) return null;
    try {
      const payload = JSON.parse(atob(parts[1].replace(/-/g, "+").replace(/_/g, "/")));
      return payload;
    } catch { return null; }
  };

  const resolveCurrentUserId = async (): Promise<string | null> => {
    const stored = localStorage.getItem("userId") || sessionStorage.getItem("userId");
    if (stored) return stored;
    const token = localStorage.getItem("token") || sessionStorage.getItem("token");
    const payload = parseJwt(token);
    const jwtId = payload?.email || payload?.sub || payload?.userId || null;
    if (jwtId) return String(jwtId);
    try {
      const { data } = await axiosClient.get<any>("/api/profile/me");
      return data?.email || data?.id || data?.userId || null;
    } catch { return null; }
  };

  const fetchMyTeams = async (uid: string) => {
    try {
      const { data } = await axiosClient.get<Team[]>("/api/teams/my-teams", { params: { userId: uid } });
      setTeams(data || []);
      if (data?.length) setSelectedTeamId(prev => prev ?? data[0].id);
      setErr(null);
    } catch (e: any) {
      console.error(e);
      setErr(e?.response?.data?.message || "โหลดทีมของฉันไม่สำเร็จ");
    }
  };

  useEffect(() => {
    (async () => {
      setLoading(true);
      const uid = await resolveCurrentUserId();
      if (!uid) {
        setErr("ไม่พบ userId ของผู้ใช้ปัจจุบัน — ตรวจสอบการเข้าสู่ระบบ/โทเคน");
        setLoading(false);
        return;
      }
      await fetchMyTeams(uid);
      setLoading(false);
    })();
  }, []);

  const selectedTeam = useMemo(
    () => (selectedTeamId ? teams.find(t => t.id === selectedTeamId) || null : null),
    [teams, selectedTeamId]
  );

  if (loading) {
    return (
      <div className="flex h-screen bg-gray-50">
        <SupervisorSidebarWidget />
        <div className="flex-1 p-8">กำลังโหลด...</div>
      </div>
    );
  }

  return (
    <div className="flex h-screen bg-gray-50">
      <SupervisorSidebarWidget />

      <div className="flex-1 p-6 md:p-8 overflow-y-auto space-y-6">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl md:text-3xl font-bold">Supervisor Dashboard</h1>
          {selectedTeam && (
            <div className="text-xs opacity-70">
              ทีมที่เลือก: <span className="font-medium">{selectedTeam.name}</span>
            </div>
          )}
        </div>

        {err && (
          <div className="rounded-xl border border-red-200 bg-red-50 p-3 text-red-700 flex items-center justify-between">
            <span>{err}</span>
            {!selectedTeamId && (
              <button
                className="ml-3 rounded-lg border px-3 py-1"
                onClick={async () => {
                  setLoading(true);
                  const uid = await resolveCurrentUserId();
                  if (uid) {
                    await fetchMyTeams(uid);
                    setErr(null);
                  }
                  setLoading(false);
                }}
              >
                ลองใหม่
              </button>
            )}
          </div>
        )}

        <div className="rounded-2xl border bg-white p-4">
          <div className="mb-3 font-semibold">ทีมของฉัน</div>
          {teams.length ? (
            <div className="flex gap-2 flex-wrap">
              {teams.map(t => (
                <button
                  key={t.id}
                  onClick={()=>setSelectedTeamId(t.id)}
                  className={`rounded-xl px-3 py-2 border ${selectedTeamId===t.id? 'bg-blue-600 text-white':'bg-white'}`}
                >
                  {t.name}
                </button>
              ))}
            </div>
          ) : (
            <div className="text-sm opacity-70">ยังไม่มีทีมที่คุณดูแล</div>
          )}
        </div>

        {selectedTeam && (
          <div className="rounded-2xl border bg-white p-4">
            <div className="mb-3">
              <div className="text-lg font-semibold">ทีม: {selectedTeam.name}</div>
              <div className="text-sm opacity-70">ตั้ง/ถอน Trainer ให้สมาชิกในทีมนี้</div>
            </div>
            <TeamMembersManager teamId={selectedTeam.id} canManage={true} />
          </div>
        )}
      </div>
    </div>
  );
}

--------------------
package model;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(
    name = "team_members",
    uniqueConstraints = {
        // กัน “สมาชิกเดียวกัน” ถูกเพิ่มซ้ำในทีมเดียวกัน
        @UniqueConstraint(name = "uk_team_member_unique", columnNames = {"team_id", "member_ID"})
    },
    indexes = {
        @Index(name = "idx_team_members_team", columnList = "team_id"),
        @Index(name = "idx_team_members_member", columnList = "member_ID"),
        @Index(name = "idx_team_members_role", columnList = "role")
    }
)
public class MemberEntity {

    @Id
    @Column(length = 21)
    private String id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "team_id", nullable = false)
    private TeamEntity team;

    /** ชื่อแสดงผลของสมาชิกในทีม (optional) */
    @Column(name = "name_members")
    private String nameMembers;

    /** ตัวระบุสมาชิกในระบบ (เราใช้ email/username) — FE/BE อ้างถึงฟิลด์นี้ */
    @Column(name = "member_ID", nullable = false)
    private String memberId;

    /**
     * บทบาทใน “ทีม”
     * ค่าที่ใช้จริงบน FE: "member" | "trainer" | "supervisor"
     */
    @Column(name = "role", nullable = false, length = 32)
    private String role;  // ค่าเริ่มต้นให้เป็น "member" ใน @PrePersist

    /** วันที่เข้าทีม (สำหรับจัดลำดับ) */
    @Column(name = "joined_at", nullable = false, updatable = false)
    private LocalDateTime joinedAt;

    // ---------- Lifecycle ----------
    @PrePersist
    public void prePersist() {
        if (this.id == null || this.id.isEmpty()) {
            this.id = UUID.randomUUID().toString().replace("-", "").substring(0, 21);
        }
        if (this.joinedAt == null) {
            this.joinedAt = LocalDateTime.now();
        }
        if (this.role == null || this.role.isBlank()) {
            this.role = "member"; // กัน role ว่าง
        }
    }

    // ---------- Getters/Setters ----------
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public TeamEntity getTeam() { return team; }
    public void setTeam(TeamEntity team) { this.team = team; }

    public String getMemberId() { return memberId; }
    public void setMemberId(String memberId) { this.memberId = memberId; }

    public String getRole() { return role; }
    public void setRole(String role) { this.role = role; }

    public LocalDateTime getJoinedAt() { return joinedAt; }
    public void setJoinedAt(LocalDateTime joinedAt) { this.joinedAt = joinedAt; }

    public String getNameMembers() { return nameMembers; }
    public void setNameMembers(String nameMembers) { this.nameMembers = nameMembers; }

    // ---------- Helper (ใช้งานสะดวก) ----------
    @Transient
    public boolean isSupervisor() { return "supervisor".equalsIgnoreCase(role); }

    @Transient
    public boolean isTrainer() { return "trainer".equalsIgnoreCase(role); }
}


// TeamResource.java

@GET
@Path("/my-teams/{userId}")
public List<TeamSummary> getTeamsByUserId(@PathParam("userId") String userId) {
    List<TeamEntity> teams = em.createQuery(
        "SELECT DISTINCT m.team FROM MemberEntity m " +
        "LEFT JOIN FETCH m.team.memberEntities " +
        "WHERE LOWER(m.memberId) = LOWER(:userId)",   // <— HERE
        TeamEntity.class
    ).setParameter("userId", userId).getResultList();

    return teams.stream().map(TeamResource::toSummary).toList();
}

@GET
@Path("/my-teams")
public List<TeamSummary> getTeamsByQueryUserId(@QueryParam("userId") String userId, @Context SecurityContext sc) {
    if (userId == null || userId.isBlank()) {
        throw new BadRequestException("userId query parameter is required");
    }
    List<TeamEntity> teams = em.createQuery(
        "SELECT DISTINCT m.team FROM MemberEntity m " +
        "LEFT JOIN FETCH m.team.memberEntities " +
        "WHERE LOWER(m.memberId) = LOWER(:userId)",   // <— AND HERE
        TeamEntity.class
    ).setParameter("userId", userId).getResultList();

    return teams.stream().map(TeamResource::toSummary).toList();
}

// TeamResource.java
@GET
@Path("/my")
@Produces(MediaType.APPLICATION_JSON)
public List<TeamSummary> getMyTeams(@Context SecurityContext sc,
                                    @Inject org.eclipse.microprofile.jwt.JsonWebToken jwt) {
    String email = jwt.getClaim("email");              // e.g. alice@example.com
    if (email == null || email.isBlank())
        throw new BadRequestException("JWT has no email claim");

    List<TeamEntity> teams = em.createQuery(
        "SELECT DISTINCT m.team FROM MemberEntity m " +
        "LEFT JOIN FETCH m.team.memberEntities " +
        "WHERE LOWER(m.memberId) = LOWER(:email)", TeamEntity.class)
        .setParameter("email", email)
        .getResultList();

    return teams.stream().map(TeamResource::toSummary).toList();
}

