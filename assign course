package AssignCourse.Resourse;

import AssignCourse.Entity.AssignmentEntity;
import AssignCourse.Entity.AssignmentItemEntity;
import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;
import model.LearningContent;
import model.MemberEntity;
import model.TeamEntity;
import model.User;
import org.eclipse.microprofile.jwt.JsonWebToken;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * AssignmentResource (v3)
 * - POST /assignments : มอบหมายคอร์สให้สมาชิกทีม
 *   Payload ตัวอย่าง:
 *   {
 *     "teamId": "3fbf03f3013f42d2b9402",
 *     "assignees": ["UeJ5XJf6np3VVCJcRx_FI","oIbg_l-oMsRKvnYZwHZlS"],
 *     "courseIds": ["7933da8c8aa14b9598ec3","ffa7eea7d281477bbf8a2"],
 *     "dueDate": "2025-11-01",
 *     "priority": "High",
 *     "note": "Urgent training required"
 *   }
 */
@Path("/assignments")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class AssignmentResource {

    private static final Logger log = LoggerFactory.getLogger(AssignmentResource.class);
    private static final String ROLE_SUPERVISOR = "supervisor";

    @Inject EntityManager em;
    @Inject JsonWebToken jwt;

    // ---------- DTO ----------
    public static class CreateAssignmentReq {
        public String teamId;
        public List<String> assignees; // user identifiers (อาจเป็น email หรือ userId)
        public List<String> courseIds; // LearningContent.id
        public String dueDate;         // YYYY-MM-DD
        public String priority;        // Low/Normal/High
        public String note;
    }
    public static class CreateAssignmentResp {
        public String assignmentId;
        public int assignedCount;
        public int courseCount;
        public int itemCount;
        public List<String> ignoredAssignees; // ส่งมาด้วยแต่ไม่อยู่ในทีม
        public List<String> missingCourseIds; // courseIds ที่หาไม่เจอ
    }

    @POST
    @Transactional
    @RolesAllowed(ROLE_SUPERVISOR)
    public Response create(CreateAssignmentReq req, @Context SecurityContext sc) {
        // ---------- actor (กัน NOT NULL) ----------
        final String actorName   = optClaim(jwt, "name").orElse(sc.getUserPrincipal().getName());
        final String actorEmail  = optClaim(jwt, "email").orElse(jwt.getSubject());
        final String actorId     = jwt.getSubject() != null ? jwt.getSubject() : actorEmail;
        final String actorAvatar = optClaim(jwt, "picture")
                .or(() -> optClaim(jwt, "avatar"))
                .or(() -> optClaim(jwt, "avatar_url"))
                .orElse(""); // DB: NOT NULL → ใช้ "" เมื่อไม่มี

        log.info("Supervisor '{}' ({}) is creating assignment. teamId={}, assignees={}, courseIds={}, dueDate={}, priority={}, noteLen={}",
                actorName, actorEmail,
                req != null ? req.teamId : null,
                req != null && req.assignees != null ? req.assignees.size() : null,
                req != null && req.courseIds != null ? req.courseIds.size() : null,
                req != null ? req.dueDate : null,
                req != null ? req.priority : null,
                req != null && req.note != null ? req.note.length() : 0);

        // ---------- validate base input ----------
        if (req == null) throw new BadRequestException("Request body is required.");
        if (isBlank(req.teamId)) throw new BadRequestException("teamId is required.");
        if (req.assignees == null || req.assignees.isEmpty()) throw new BadRequestException("assignees must not be empty.");
        if (req.courseIds == null  || req.courseIds.isEmpty()) throw new BadRequestException("courseIds must not be empty.");

        // ---------- team & members ----------
        TeamEntity team = em.find(TeamEntity.class, req.teamId);
        if (team == null) throw new BadRequestException("Invalid teamId.");
        team.getMemberEntities().size(); // load lazy

        // รวม identifiers สมาชิกทีม: memberId และ userID (ถ้ามี)
        Set<String> teamIdsExact = team.getMemberEntities().stream()
                .flatMap(m -> {
                    List<String> ids = new ArrayList<>();
                    if (notBlank(m.getMemberId())) ids.add(m.getMemberId());
                    try {
                        var method = MemberEntity.class.getMethod("getUserID");
                        Object v = method.invoke(m);
                        if (v != null && !String.valueOf(v).isBlank()) ids.add(String.valueOf(v));
                    } catch (Exception ignored) {}
                    return ids.stream();
                })
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toCollection(LinkedHashSet::new));
        Set<String> teamIdsLower = teamIdsExact.stream().map(String::toLowerCase).collect(Collectors.toSet());

        // ---------- normalize & filter assignees ----------
        List<String> requestedExact = req.assignees.stream()
                .filter(Objects::nonNull).map(String::trim).filter(s -> !s.isEmpty()).toList();
        List<String> requestedLower = requestedExact.stream().map(String::toLowerCase).toList();

        // หาตัวที่ไม่อยู่ในทีม (ส่งกลับเพื่อแจ้งเตือน)
        Set<String> notInTeamLower = new LinkedHashSet<>(requestedLower);
        notInTeamLower.removeAll(teamIdsLower);

        // เหลือเฉพาะที่อยู่ในทีม (ignore case)
        List<String> validAssigneesExact = new ArrayList<>();
        for (int i = 0; i < requestedExact.size(); i++) {
            String ex = requestedExact.get(i);
            String lo = requestedLower.get(i);
            if (teamIdsExact.contains(ex) || teamIdsLower.contains(lo)) {
                validAssigneesExact.add(ex);
            }
        }
        if (validAssigneesExact.isEmpty()) {
            throw new BadRequestException("No valid assignees in the team.");
        }

        // ---------- map assignees -> emails ----------
        Set<String> keys = validAssigneesExact.stream().map(String::toLowerCase).collect(Collectors.toSet());
        List<User> candidates = em.createQuery("""
                SELECT u FROM User u
                WHERE LOWER(u.id) IN :xs OR LOWER(u.email) IN :xs
                """, User.class)
                .setParameter("xs", keys)
                .getResultList();

        Map<String, String> idLowerToEmailLower = new HashMap<>();
        Map<String, String> emailLowerToEmailLower = new HashMap<>();
        for (User u : candidates) {
            String idL = safeLower(u.getId() != null ? u.getId().toString() : null);
            String emL = safeLower(u.getEmail());
            if (idL != null && emL != null) idLowerToEmailLower.put(idL, emL);
            if (emL != null) emailLowerToEmailLower.put(emL, emL);
        }

        List<String> assigneeEmails = new ArrayList<>();
        for (String ex : validAssigneesExact) {
            String lo = ex.toLowerCase();
            String email = emailLowerToEmailLower.get(lo);
            if (email == null) email = idLowerToEmailLower.get(lo);
            if (email == null && ex.contains("@")) email = ex.toLowerCase(); // ถ้า ex เป็นอีเมลอยู่แล้ว
            if (email != null) assigneeEmails.add(email);
        }
        assigneeEmails = assigneeEmails.stream().distinct().toList();
        if (assigneeEmails.isEmpty()) throw new BadRequestException("No valid assignee emails found.");

        // ---------- validate courses & หา missing ----------
        List<String> reqCourseIdsUniq = req.courseIds.stream()
                .filter(Objects::nonNull).map(String::trim).filter(s -> !s.isEmpty())
                .distinct().toList();

        List<LearningContent> contents = em.createQuery("""
            SELECT lc FROM LearningContent lc WHERE lc.id IN :ids
        """, LearningContent.class)
                .setParameter("ids", reqCourseIdsUniq)
                .getResultList();

        Set<String> foundIds = contents.stream().map(LearningContent::getId).collect(Collectors.toSet());
        List<String> missingCourseIds = reqCourseIdsUniq.stream().filter(id -> !foundIds.contains(id)).toList();
        if (contents.isEmpty()) throw new BadRequestException("No valid courseIds found.");
        List<String> contentIdsUniq = contents.stream().map(LearningContent::getId).distinct().toList();

        // ---------- due date ----------
        LocalDateTime dueAt = null;
        if (notBlank(req.dueDate)) {
            try {
                dueAt = LocalDate.parse(req.dueDate).atTime(LocalTime.MAX);
            } catch (Exception e) {
                throw new BadRequestException("Invalid dueDate format, expected YYYY-MM-DD");
            }
        }

        // ---------- persist header (กัน NOT NULL ทุกช่อง) ----------
        AssignmentEntity header = new AssignmentEntity();
        header.setId(UUID.randomUUID());                 // ถ้า entity ใช้ @GeneratedValue ก็ลบได้
        header.setTeamId(req.teamId);
        header.setCreatedAt(LocalDateTime.now());

        header.setCreaterId(nvl(actorId));
        header.setCreaterEmail(nvl(actorEmail));
        header.setCreaterName(nvl(actorName));
        header.setCreaterAvatar(nvl(actorAvatar));       // สำคัญ: DB not-null

        header.setPriority(notBlank(req.priority) ? req.priority : "Normal");
        header.setNotes(req.note);
        if (dueAt != null) header.setDueDate(dueAt);

        em.persist(header);

        // ---------- persist items (de-dup ทั้งคู่) ----------
        int itemCount = 0;
        for (String email : assigneeEmails) {
            for (String contentId : contentIdsUniq) {
                AssignmentItemEntity item = new AssignmentItemEntity();
                item.setAssignment(header);
                item.setDestinationEmail(email);
                item.setContentId(contentId);
                em.persist(item);
                itemCount++;
            }
        }

        // ---------- response ----------
        CreateAssignmentResp resp = new CreateAssignmentResp();
        resp.assignmentId     = header.getId().toString();
        resp.assignedCount    = assigneeEmails.size();
        resp.courseCount      = contentIdsUniq.size();
        resp.itemCount        = itemCount;
        resp.ignoredAssignees = new ArrayList<>(notInTeamLower); // (lowercase) เพื่อบอกว่าไม่อยู่ในทีม
        resp.missingCourseIds = missingCourseIds;

        if (!resp.ignoredAssignees.isEmpty()) {
            log.warn("Ignored assignees (not in team {}): {}", req.teamId, resp.ignoredAssignees);
        }
        if (!resp.missingCourseIds.isEmpty()) {
            log.warn("Missing courseIds ignored: {}", resp.missingCourseIds);
        }

        log.info("Assignment created: id={}, assignees={}, courses={}, items={}",
                resp.assignmentId, resp.assignedCount, resp.courseCount, resp.itemCount);

        return Response.status(Response.Status.CREATED).entity(resp).build();
    }

    // ---------- helpers ----------
    private static boolean isBlank(String s){ return s == null || s.isBlank(); }
    private static boolean notBlank(String s){ return s != null && !s.isBlank(); }
    private static String safeLower(String s){ return s == null ? null : s.toLowerCase(); }
    private static String nvl(String s){ return s == null ? "" : s; }
    private static Optional<String> optClaim(JsonWebToken jwt, String claim) {
        try {
            Object v = jwt.getClaim(claim);
            return Optional.ofNullable(v).map(Object::toString);
        } catch (Exception e) {
            return Optional.empty();
        }
    }
}
