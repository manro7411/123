2025-10-15 10:52:47,531 ERROR [io.qua.ver.htt.run.QuarkusErrorHandler] (executor-thread-1) HTTP Request to /assignments failed, error id: 4d5310b7-064b-4df6-8e0b-e7c028b318f4-5

Exception in AssignmentResource.java:185
          183          header.setNotes(req.note);                                                                                                                                                                                   
          184          if (dueAt != null) header.setDueDate(dueAt);                                                                                                                                                                 
        ? 185          em.merge(header);                                                                                                                                                                                            
          186          // ---------- persist items ----------                                                                                                                                                                       
          187          int createdCount = 0;                                                                                                                                                                                        

Exception in AssignmentResource.java:185
          183          header.setNotes(req.note);                                                                                                                                                                                   
          184          if (dueAt != null) header.setDueDate(dueAt);                                                                                                                                                                 
        ? 185          em.merge(header);                                                                                                                                                                                            
          186          // ---------- persist items ----------                                                                                                                                                                       
          187          int createdCount = 0;: jakarta.persistence.OptimisticLockException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect): [AssignCourse.Entity.AssignmentEntity#b9198231-089c-451b-a9d1-c6a894d3ab27]                                                                                                                                                                                                      
        at org.hibernate.internal.ExceptionConverterImpl.wrapStaleStateException(ExceptionConverterImpl.java:209)                                                                                                                   
        at org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:95)                                                                                                                                    
        at org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:167)                                                                                                                                   
        at org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:173)                                                                                                                                   
        at org.hibernate.internal.SessionImpl.fireMerge(SessionImpl.java:865)                                                                                                                                                       
        at org.hibernate.internal.SessionImpl.merge(SessionImpl.java:840)                                                                                                                                                           
        at io.quarkus.hibernate.orm.runtime.session.TransactionScopedSession.merge(TransactionScopedSession.java:169)                                                                                                               
        at org.hibernate.engine.spi.SessionLazyDelegator.merge(SessionLazyDelegator.java:272)                                                                                                                                       
        at org.hibernate.Session_OpdLahisOZ9nWRPXMsEFQmQU03A_Synthetic_ClientProxy.merge(Unknown Source)                                                                                                                            
        at AssignCourse.Resourse.AssignmentResource.create(AssignmentResource.java:185)                                                                                                                                             
        at AssignCourse.Resourse.AssignmentResource_Subclass.create$$superforward(Unknown Source)                                                                                                                                   
        at AssignCourse.Resourse.AssignmentResource_Subclass$$function$$4.apply(Unknown Source)                                                                                                                                     
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:73)                                                                                                                         
        at io.quarkus.arc.impl.AroundInvokeInvocationContext$NextAroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:97)                                                                                       
        at io.quarkus.security.runtime.interceptor.SecurityHandler.handle(SecurityHandler.java:27)                                                                                                                                  
        at io.quarkus.security.runtime.interceptor.RolesAllowedInterceptor.intercept(RolesAllowedInterceptor.java:29)                                                                                                               
        at io.quarkus.security.runtime.interceptor.RolesAllowedInterceptor_Bean.intercept(Unknown Source)                                                                                                                           
        at io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:42)                                                                                                                                          
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:70)                                                                                                                         
        at io.quarkus.arc.impl.AroundInvokeInvocationContext$NextAroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:97)                                                                                       
        at io.quarkus.resteasy.reactive.server.runtime.StandardSecurityCheckInterceptor.intercept(StandardSecurityCheckInterceptor.java:44)                                                                                         
        at io.quarkus.resteasy.reactive.server.runtime.StandardSecurityCheckInterceptor_RolesAllowedInterceptor_Bean.intercept(Unknown Source)                                                                                      
        at io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:42)                                                                                                                                          
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:70)                                                                                                                         
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:62)                                                                                                                         
        at io.quarkus.narayana.jta.runtime.interceptor.TransactionalInterceptorBase.invokeInOurTx(TransactionalInterceptorBase.java:136)                                                                                            
        at io.quarkus.narayana.jta.runtime.interceptor.TransactionalInterceptorBase.invokeInOurTx(TransactionalInterceptorBase.java:107)                                                                                            
        at io.quarkus.narayana.jta.runtime.interceptor.TransactionalInterceptorRequired.doIntercept(TransactionalInterceptorRequired.java:38)                                                                                       
        at io.quarkus.narayana.jta.runtime.interceptor.TransactionalInterceptorBase.intercept(TransactionalInterceptorBase.java:61)                                                                                                 
        at io.quarkus.narayana.jta.runtime.interceptor.TransactionalInterceptorRequired.intercept(TransactionalInterceptorRequired.java:32)                                                                                         
        at io.quarkus.narayana.jta.runtime.interceptor.TransactionalInterceptorRequired_Bean.intercept(Unknown Source)                                                                                                              
        at io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:42)                                                                                                                                          
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.perform(AroundInvokeInvocationContext.java:30)                                                                                                                         
        at io.quarkus.arc.impl.InvocationContexts.performAroundInvoke(InvocationContexts.java:27)                                                                                                                                   
        at AssignCourse.Resourse.AssignmentResource_Subclass.create(Unknown Source)                                                                                                                                                 
        at AssignCourse.Resourse.AssignmentResource$quarkusrestinvoker$create_be8456ded4b100372e114b1446e137321177ca1f.invoke(Unknown Source)                                                                                       
        at org.jboss.resteasy.reactive.server.handlers.InvocationHandler.handle(InvocationHandler.java:29)                                                                                                                          
        at io.quarkus.resteasy.reactive.server.runtime.QuarkusResteasyReactiveRequestContext.invokeHandler(QuarkusResteasyReactiveRequestContext.java:141)                                                                          
        at org.jboss.resteasy.reactive.common.core.AbstractResteasyReactiveContext.run(AbstractResteasyReactiveContext.java:147)                                                                                                    
        at io.quarkus.vertx.core.runtime.VertxCoreRecorder$15.runWith(VertxCoreRecorder.java:637)                                                                                                                                   
        at org.jboss.threads.EnhancedQueueExecutor$Task.doRunWith(EnhancedQueueExecutor.java:2651)                                                                                                                                  
        at org.jboss.threads.EnhancedQueueExecutor$Task.run(EnhancedQueueExecutor.java:2630)                                                                                                                                        
        at org.jboss.threads.EnhancedQueueExecutor.runThreadBody(EnhancedQueueExecutor.java:1622)                                                                                                                                   
        at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1589)                                                                                                                                  
        at org.jboss.threads.DelegatingRunnable.run(DelegatingRunnable.java:11)                                                                                                                                                     
        at org.jboss.threads.ThreadLocalResettingRunnable.run(ThreadLocalResettingRunnable.java:11)                                                                                                                                 
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)                                                                                                                                    
        at java.base/java.lang.Thread.run(Thread.java:1583)                                                                                                                                                                         
Caused by: org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect): [AssignCourse.Entity.AssignmentEntity#b9198231-089c-451b-a9d1-c6a894d3ab27]         
        at org.hibernate.event.internal.DefaultMergeEventListener.entityIsDetached(DefaultMergeEventListener.java:426)                                                                                                              
        at org.hibernate.event.internal.DefaultMergeEventListener.merge(DefaultMergeEventListener.java:214)                                                                                                                         
        at org.hibernate.event.internal.DefaultMergeEventListener.doMerge(DefaultMergeEventListener.java:152)                                                                                                                       
        at org.hibernate.event.internal.DefaultMergeEventListener.onMerge(DefaultMergeEventListener.java:132)                                                                                                                       
        at org.hibernate.event.internal.DefaultMergeEventListener.onMerge(DefaultMergeEventListener.java:89)                                                                                                                        
        at org.hibernate.event.service.internal.

package AssignCourse.Resourse;

import AssignCourse.Entity.AssignmentEntity;
import AssignCourse.Entity.AssignmentItemEntity;
import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import model.LearningContent;
import model.MemberEntity;
import model.TeamEntity;
import model.User;
import org.eclipse.microprofile.jwt.JsonWebToken;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

@Path("/assignments")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class AssignmentResource {

    private static final Logger log = LoggerFactory.getLogger(AssignmentResource.class);
    private static final String ROLE_SUPERVISOR = "supervisor";

    @Inject EntityManager em;
    @Inject JsonWebToken jwt;

    // ---------- DTO ----------
    public static class CreateAssignmentReq {
        public String teamId;
        public List<String> assignees; // user identifiers (อาจเป็น email หรือ userId)
        public List<String> courseIds; // LearningContent.id
        public String dueDate;         // YYYY-MM-DD
        public String priority;        // Low/Normal/High
        public String note;
    }
    public static class CreateAssignmentResp {
        public String assignmentId;
        public int assignedCount;
        public int courseCount;
    }

    @POST
    @Transactional
    @RolesAllowed(ROLE_SUPERVISOR)
    public Response create(CreateAssignmentReq req, @Context SecurityContext sc) {
        final String actorName  = Optional.ofNullable(jwt.getClaim("name")).map(Object::toString).orElse(sc.getUserPrincipal().getName());
        final String actorEmail = Optional.ofNullable(jwt.getClaim("email")).map(Object::toString).orElse(jwt.getSubject());
        final String actorId    = Optional.ofNullable(jwt.getSubject()).orElse(actorEmail);
        final String actorAvatar= // รับจาก claim ชื่อที่พบได้บ่อย ๆ
                Optional.ofNullable(jwt.getClaim("picture"))
                        .or(() -> Optional.ofNullable(jwt.getClaim("avatar")))
                        .or(() -> Optional.ofNullable(jwt.getClaim("avatar_url")))
                        .map(Object::toString)
                        .orElse(""); // กัน null เพราะ DB not-null

        log.info("Supervisor '{}' ({}) is creating assignment. Payload: teamId={}, assignees={}, courseIds={}, dueDate={}, priority={}, noteLen={}",
                actorName, actorEmail, req != null ? req.teamId : null,
                req != null ? (req.assignees != null ? req.assignees.size() : 0) : null,
                req != null ? (req.courseIds  != null ? req.courseIds.size()  : 0) : null,
                req != null ? req.dueDate : null,
                req != null ? req.priority : null,
                req != null && req.note != null ? req.note.length() : 0);

        // ---------- validate base input ----------
        if (req == null) throw new BadRequestException("Request body is required.");
        if (isBlank(req.teamId)) throw new BadRequestException("teamId is required.");
        if (req.assignees == null || req.assignees.isEmpty()) throw new BadRequestException("assignees is required and must not be empty.");
        if (req.courseIds == null  || req.courseIds.isEmpty()) throw new BadRequestException("courseIds is required and must not be empty.");

        // ---------- team & members ----------
        TeamEntity team = em.find(TeamEntity.class, req.teamId);
        if (team == null) throw new BadRequestException("Invalid teamId");
        // load members (lazy)
        team.getMemberEntities().size();

        // เก็บ identifiers ของสมาชิกทีม (ทั้ง memberId และ userID เผื่อโปรเจ็กต์คุณใช้ต่างที่กัน)
        Set<String> teamIdsExact = team.getMemberEntities().stream()
                .flatMap(m -> {
                    List<String> ids = new ArrayList<>();
                    if (notBlank(m.getMemberId())) ids.add(m.getMemberId());
                    try {
                        // บางที่ใช้ userID เป็น email
                        var method = m.getClass().getMethod("getUserID");
                        Object v = method.invoke(m);
                        if (v != null && !String.valueOf(v).isBlank()) ids.add(String.valueOf(v));
                    } catch (Exception ignored) {}
                    return ids.stream();
                })
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toCollection(LinkedHashSet::new));

        // สำหรับเทียบแบบไม่สนตัวพิมพ์
        Set<String> teamIdsLower = teamIdsExact.stream().map(String::toLowerCase).collect(Collectors.toSet());

        // ---------- normalize assignees ----------
        List<String> requestedExact = req.assignees.stream()
                .filter(Objects::nonNull).map(String::trim).filter(s -> !s.isEmpty()).toList();
        List<String> requestedLower = requestedExact.stream().map(String::toLowerCase).toList();

        // ตรวจว่าเป็นสมาชิกทีม (แบบ ignore case)
        List<String> validAssigneesExact = new ArrayList<>();
        for (int i = 0; i < requestedExact.size(); i++) {
            String ex = requestedExact.get(i);
            String lo = requestedLower.get(i);
            if (teamIdsExact.contains(ex) || teamIdsLower.contains(lo)) {
                validAssigneesExact.add(ex);
            }
        }
        if (validAssigneesExact.isEmpty()) {
            throw new BadRequestException("No valid assignees in the team.");
        }

        // ---------- resolve assignees -> email ----------
        // พยายามแมปจาก User โดยดูทั้ง id และ email แบบ ignore-case
        List<String> lowers = validAssigneesExact.stream().map(String::toLowerCase).toList();
        // ดึงมาเฉพาะที่อาจแมตช์ (เลี่ยง SELECT ทั้งตาราง)
        List<User> candidates = em.createQuery("""
                SELECT u FROM User u
                WHERE LOWER(u.id) IN :xs OR LOWER(u.email) IN :xs
                """, User.class)
                .setParameter("xs", new HashSet<>(lowers))
                .getResultList();

        Map<String, String> idLowerToEmail = new HashMap<>();
        Map<String, String> emailLowerToEmail = new HashMap<>();
        for (User u : candidates) {
            String idL = safeLower(u.getId() != null ? u.getId().toString() : null);
            String emL = safeLower(u.getEmail());
            if (idL != null && emL != null) idLowerToEmail.put(idL, emL);
            if (emL != null) emailLowerToEmail.put(emL, emL);
        }

        List<String> assigneeEmails = new ArrayList<>();
        for (String ex : validAssigneesExact) {
            String lo = ex.toLowerCase();
            String email = emailLowerToEmail.get(lo);
            if (email == null) email = idLowerToEmail.get(lo);
            // ยังไม่ได้? ถ้า ex เป็นอีเมลจริงอยู่แล้วให้ใช้ได้เลย
            if (email == null && ex.contains("@")) email = ex.toLowerCase();
            if (email != null) assigneeEmails.add(email);
        }
        assigneeEmails = assigneeEmails.stream().distinct().toList();
        if (assigneeEmails.isEmpty()) throw new BadRequestException("No valid assignee emails found.");

        // ---------- validate courses ----------
        List<LearningContent> contents = em.createQuery("""
            SELECT lc FROM LearningContent lc WHERE lc.id IN :ids
        """, LearningContent.class)
                .setParameter("ids", req.courseIds)
                .getResultList();
        if (contents.isEmpty()) throw new BadRequestException("No valid courseIds found.");

        // ---------- parse due date ----------
        LocalDateTime dueAt = null;
        if (notBlank(req.dueDate)) {
            try {
                dueAt = LocalDate.parse(req.dueDate).atTime(LocalTime.MAX);
            } catch (Exception e) {
                throw new BadRequestException("Invalid dueDate format, expected YYYY-MM-DD");
            }
        }

        // ---------- persist header (ใส่ทุกฟิลด์ NOT NULL ให้ครบ) ----------
        AssignmentEntity header = new AssignmentEntity();
        header.setId(UUID.randomUUID());
        header.setTeamId(req.teamId);
        header.setCreatedAt(LocalDateTime.now());

        header.setCreaterId(actorId);
        header.setCreaterEmail(actorEmail != null ? actorEmail : "");
        header.setCreaterName(actorName != null ? actorName : "");
        header.setCreaterAvatar("https://example.com/default-avatar.png"); // or extract from JWT

        header.setPriority(notBlank(req.priority) ? req.priority : "Normal");
        header.setNotes(req.note);
        if (dueAt != null) header.setDueDate(dueAt);
        em.merge(header);
        // ---------- persist items ----------
        int createdCount = 0;
        for (String email : assigneeEmails) {
            for (LearningContent lc : contents) {
                AssignmentItemEntity item = new AssignmentItemEntity();
                item.setAssignment(header);
                item.setDestinationEmail(email);
                item.setContentId(lc.getId());
                em.persist(item);
                createdCount++;
            }
        }

        // ---------- response ----------
        CreateAssignmentResp resp = new CreateAssignmentResp();
        resp.assignmentId = header.getId().toString();
        resp.assignedCount = assigneeEmails.size();
        resp.courseCount = contents.size();

        log.info("Assignment created: id={}, assignees={}, courses={}, items={}",
                resp.assignmentId, resp.assignedCount, resp.courseCount, createdCount);
        return Response.status(Response.Status.CREATED).entity(resp).build();
    }

    // ---------- helpers ----------
    private static boolean isBlank(String s){ return s == null || s.isBlank(); }
    private static boolean notBlank(String s){ return s != null && !s.isBlank(); }
    private static String safeLower(String s){ return s == null ? null : s.toLowerCase(); }
}

