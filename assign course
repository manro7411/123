package AssignCourse.Resourse;

import AssignCourse.Entity.AssignmentEntity;
import AssignCourse.Entity.AssignmentItemEntity;
import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import model.LearningContent;
import model.MemberEntity;
import model.TeamEntity;
import model.User;
import org.eclipse.microprofile.jwt.JsonWebToken;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

@Path("/assignments")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class AssignmentResource {

    private static final Logger log = LoggerFactory.getLogger(AssignmentResource.class);
    private static final String ROLE_SUPERVISOR = "supervisor";

    @Inject EntityManager em;
    @Inject JsonWebToken jwt;

    // ---------- DTO ----------
    public static class CreateAssignmentReq {
        public String teamId;
        public List<String> assignees; // user identifiers (อาจเป็น email หรือ userId)
        public List<String> courseIds; // LearningContent.id
        public String dueDate;         // YYYY-MM-DD
        public String priority;        // Low/Normal/High
        public String note;
    }
    public static class CreateAssignmentResp {
        public String assignmentId;
        public int assignedCount;
        public int courseCount;
    }

    @POST
    @Transactional
    @RolesAllowed(ROLE_SUPERVISOR)
    public Response create(CreateAssignmentReq req, @Context SecurityContext sc) {
        final String actorName  = Optional.ofNullable(jwt.getClaim("name")).map(Object::toString).orElse(sc.getUserPrincipal().getName());
        final String actorEmail = Optional.ofNullable(jwt.getClaim("email")).map(Object::toString).orElse(jwt.getSubject());
        final String actorId    = Optional.ofNullable(jwt.getSubject()).orElse(actorEmail);
        final String actorAvatar= // รับจาก claim ชื่อที่พบได้บ่อย ๆ
                Optional.ofNullable(jwt.getClaim("picture"))
                        .or(() -> Optional.ofNullable(jwt.getClaim("avatar")))
                        .or(() -> Optional.ofNullable(jwt.getClaim("avatar_url")))
                        .map(Object::toString)
                        .orElse(""); // กัน null เพราะ DB not-null

        log.info("Supervisor '{}' ({}) is creating assignment. Payload: teamId={}, assignees={}, courseIds={}, dueDate={}, priority={}, noteLen={}",
                actorName, actorEmail, req != null ? req.teamId : null,
                req != null ? (req.assignees != null ? req.assignees.size() : 0) : null,
                req != null ? (req.courseIds  != null ? req.courseIds.size()  : 0) : null,
                req != null ? req.dueDate : null,
                req != null ? req.priority : null,
                req != null && req.note != null ? req.note.length() : 0);

        // ---------- validate base input ----------
        if (req == null) throw new BadRequestException("Request body is required.");
        if (isBlank(req.teamId)) throw new BadRequestException("teamId is required.");
        if (req.assignees == null || req.assignees.isEmpty()) throw new BadRequestException("assignees is required and must not be empty.");
        if (req.courseIds == null  || req.courseIds.isEmpty()) throw new BadRequestException("courseIds is required and must not be empty.");

        // ---------- team & members ----------
        TeamEntity team = em.find(TeamEntity.class, req.teamId);
        if (team == null) throw new BadRequestException("Invalid teamId");
        // load members (lazy)
        team.getMemberEntities().size();

        // เก็บ identifiers ของสมาชิกทีม (ทั้ง memberId และ userID เผื่อโปรเจ็กต์คุณใช้ต่างที่กัน)
        Set<String> teamIdsExact = team.getMemberEntities().stream()
                .flatMap(m -> {
                    List<String> ids = new ArrayList<>();
                    if (notBlank(m.getMemberId())) ids.add(m.getMemberId());
                    try {
                        // บางที่ใช้ userID เป็น email
                        var method = m.getClass().getMethod("getUserID");
                        Object v = method.invoke(m);
                        if (v != null && !String.valueOf(v).isBlank()) ids.add(String.valueOf(v));
                    } catch (Exception ignored) {}
                    return ids.stream();
                })
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toCollection(LinkedHashSet::new));

        // สำหรับเทียบแบบไม่สนตัวพิมพ์
        Set<String> teamIdsLower = teamIdsExact.stream().map(String::toLowerCase).collect(Collectors.toSet());

        // ---------- normalize assignees ----------
        List<String> requestedExact = req.assignees.stream()
                .filter(Objects::nonNull).map(String::trim).filter(s -> !s.isEmpty()).toList();
        List<String> requestedLower = requestedExact.stream().map(String::toLowerCase).toList();

        // ตรวจว่าเป็นสมาชิกทีม (แบบ ignore case)
        List<String> validAssigneesExact = new ArrayList<>();
        for (int i = 0; i < requestedExact.size(); i++) {
            String ex = requestedExact.get(i);
            String lo = requestedLower.get(i);
            if (teamIdsExact.contains(ex) || teamIdsLower.contains(lo)) {
                validAssigneesExact.add(ex);
            }
        }
        if (validAssigneesExact.isEmpty()) {
            throw new BadRequestException("No valid assignees in the team.");
        }

        // ---------- resolve assignees -> email ----------
        // พยายามแมปจาก User โดยดูทั้ง id และ email แบบ ignore-case
        List<String> lowers = validAssigneesExact.stream().map(String::toLowerCase).toList();
        // ดึงมาเฉพาะที่อาจแมตช์ (เลี่ยง SELECT ทั้งตาราง)
        List<User> candidates = em.createQuery("""
                SELECT u FROM User u
                WHERE LOWER(u.id) IN :xs OR LOWER(u.email) IN :xs
                """, User.class)
                .setParameter("xs", new HashSet<>(lowers))
                .getResultList();

        Map<String, String> idLowerToEmail = new HashMap<>();
        Map<String, String> emailLowerToEmail = new HashMap<>();
        for (User u : candidates) {
            String idL = safeLower(u.getId() != null ? u.getId().toString() : null);
            String emL = safeLower(u.getEmail());
            if (idL != null && emL != null) idLowerToEmail.put(idL, emL);
            if (emL != null) emailLowerToEmail.put(emL, emL);
        }

        List<String> assigneeEmails = new ArrayList<>();
        for (String ex : validAssigneesExact) {
            String lo = ex.toLowerCase();
            String email = emailLowerToEmail.get(lo);
            if (email == null) email = idLowerToEmail.get(lo);
            // ยังไม่ได้? ถ้า ex เป็นอีเมลจริงอยู่แล้วให้ใช้ได้เลย
            if (email == null && ex.contains("@")) email = ex.toLowerCase();
            if (email != null) assigneeEmails.add(email);
        }
        assigneeEmails = assigneeEmails.stream().distinct().toList();
        if (assigneeEmails.isEmpty()) throw new BadRequestException("No valid assignee emails found.");

        // ---------- validate courses ----------
        List<LearningContent> contents = em.createQuery("""
            SELECT lc FROM LearningContent lc WHERE lc.id IN :ids
        """, LearningContent.class)
                .setParameter("ids", req.courseIds)
                .getResultList();
        if (contents.isEmpty()) throw new BadRequestException("No valid courseIds found.");

        // ---------- parse due date ----------
        LocalDateTime dueAt = null;
        if (notBlank(req.dueDate)) {
            try {
                dueAt = LocalDate.parse(req.dueDate).atTime(LocalTime.MAX);
            } catch (Exception e) {
                throw new BadRequestException("Invalid dueDate format, expected YYYY-MM-DD");
            }
        }

        // ---------- persist header (ใส่ทุกฟิลด์ NOT NULL ให้ครบ) ----------
        AssignmentEntity header = new AssignmentEntity();
        header.setId(UUID.randomUUID());
        header.setTeamId(req.teamId);
        header.setCreatedAt(LocalDateTime.now());

        header.setCreaterId(actorId);
        header.setCreaterEmail(actorEmail != null ? actorEmail : "");
        header.setCreaterName(actorName != null ? actorName : "");
        header.setCreaterAvatar(actorAvatar != null ? actorAvatar : ""); // สำคัญ: กัน NOT NULL

        header.setPriority(notBlank(req.priority) ? req.priority : "Normal");
        header.setNotes(req.note);
        if (dueAt != null) header.setDueDate(dueAt);

        em.persist(header);

        // ---------- persist items ----------
        int createdCount = 0;
        for (String email : assigneeEmails) {
            for (LearningContent lc : contents) {
                AssignmentItemEntity item = new AssignmentItemEntity();
                item.setAssignment(header);
                item.setDestinationEmail(email);
                item.setContentId(lc.getId());
                em.persist(item);
                createdCount++;
            }
        }

        // ---------- response ----------
        CreateAssignmentResp resp = new CreateAssignmentResp();
        resp.assignmentId = header.getId().toString();
        resp.assignedCount = assigneeEmails.size();
        resp.courseCount = contents.size();

        log.info("Assignment created: id={}, assignees={}, courses={}, items={}",
                resp.assignmentId, resp.assignedCount, resp.courseCount, createdCount);
        return Response.status(Response.Status.CREATED).entity(resp).build();
    }

    // ---------- helpers ----------
    private static boolean isBlank(String s){ return s == null || s.isBlank(); }
    private static boolean notBlank(String s){ return s != null && !s.isBlank(); }
    private static String safeLower(String s){ return s == null ? null : s.toLowerCase(); }
}
