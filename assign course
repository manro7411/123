package AssignCourse.Resourse;

import AssignCourse.Entity.AssignmentEntity;
import AssignCourse.Entity.AssignmentItemEntity;
import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;
import model.LearningContent;
import model.MemberEntity;
import model.TeamEntity;
import model.User;
import org.eclipse.microprofile.jwt.JsonWebToken;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * AssignmentResource (v2)
 * - POST /assignments : มอบหมายคอร์สให้สมาชิกทีม
 * - รองรับ payload:
 *   {
 *     "teamId": "3fbf03f3013f42d2b9402",
 *     "assignees": ["UeJ5XJf6np3VVCJcRx_FI", "oIbg_l-oMsRKvnYZwHZlS"],
 *     "courseIds": ["7933da8c8aa14b9598ec3", "ffa7eea7d281477bbf8a2"],
 *     "dueDate": "YYYY-MM-DD",
 *     "priority": "Low|Normal|High",
 *     "note": "ข้อความโน้ต"
 *   }
 */
@Path("/assignments")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class AssignmentResource {

    private static final Logger log = LoggerFactory.getLogger(AssignmentResource.class);
    private static final String ROLE_SUPERVISOR = "supervisor";

    @Inject EntityManager em;
    @Inject JsonWebToken jwt;

    // ======================= DTO =======================
    public static class CreateAssignmentReq {
        public String teamId;
        public List<String> assignees; // user identifiers (อาจเป็น email หรือ userId)
        public List<String> courseIds; // LearningContent.id
        public String dueDate;         // YYYY-MM-DD
        public String priority;        // Low/Normal/High
        public String note;
    }
    public static class CreateAssignmentResp {
        public String assignmentId;
        public int assignedCount;
        public int courseCount;
        public int itemCount;
        public List<String> ignoredAssignees; // รายชื่อที่ไม่อยู่ในทีม ถูกละทิ้ง
        public List<String> missingCourseIds; // courseIds ที่หาไม่พบ
    }

    // ======================= API =======================
    @POST
    @Transactional
    @RolesAllowed(ROLE_SUPERVISOR)
    public Response create(CreateAssignmentReq req, @Context SecurityContext sc) {
        // ---- actor info (กัน NOT NULL ทุกฟิลด์ header) ----
        final String actorName   = optClaim(jwt, "name").orElse(sc.getUserPrincipal().getName());
        final String actorEmail  = optClaim(jwt, "email").orElse(jwt.getSubject());
        final String actorId     = jwt.getSubject() != null ? jwt.getSubject() : actorEmail;
        final String actorAvatar = optClaim(jwt, "picture")
                .or(() -> optClaim(jwt, "avatar"))
                .or(() -> optClaim(jwt, "avatar_url"))
                .orElse(""); // DB เป็น NOT NULL → ใช้ "" แทน

        log.info("Supervisor '{}' ({}) is creating assignment. Payload: teamId={}, assignees={}, courseIds={}, dueDate={}, priority={}, noteLen={}",
                actorName, actorEmail,
                req != null ? req.teamId : null,
                req != null && req.assignees != null ? req.assignees.size() : null,
                req != null && req.courseIds != null ? req.courseIds.size() : null,
                req != null ? req.dueDate : null,
                req != null ? req.priority : null,
                req != null && req.note != null ? req.note.length() : 0);

        // ---- basic validation ----
        if (req == null) throw new BadRequestException("Request body is required.");
        if (isBlank(req.teamId)) throw new BadRequestException("teamId is required.");
        if (req.assignees == null || req.assignees.isEmpty()) throw new BadRequestException("assignees must not be empty.");
        if (req.courseIds == null  || req.courseIds.isEmpty()) throw new BadRequestException("courseIds must not be empty.");

        // ---- load team & members ----
        TeamEntity team = em.find(TeamEntity.class, req.teamId);
        if (team == null) throw new BadRequestException("Invalid teamId.");
        // load lazy
        team.getMemberEntities().size();

        // รวบรวม identifier ของสมาชิกทีม (memberId และ userID ถ้ามี)
        Set<String> teamIdsExact = team.getMemberEntities().stream()
                .flatMap(m -> {
                    List<String> ids = new ArrayList<>();
                    if (notBlank(m.getMemberId())) ids.add(m.getMemberId());
                    // ถ้าโปรเจ็กต์มี getUserID จริง ให้ใช้ด้วย (รองรับหลายสคีมา)
                    try {
                        var method = MemberEntity.class.getMethod("getUserID");
                        Object v = method.invoke(m);
                        if (v != null && !String.valueOf(v).isBlank()) ids.add(String.valueOf(v));
                    } catch (Exception ignored) {}
                    return ids.stream();
                })
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toCollection(LinkedHashSet::new));

        Set<String> teamIdsLower = teamIdsExact.stream().map(String::toLowerCase).collect(Collectors.toSet());

        // ---- normalize & validate assignees vs team ----
        List<String> requestedExact = req.assignees.stream()
                .filter(Objects::nonNull).map(String::trim).filter(s -> !s.isEmpty()).toList();
        List<String> requestedLower = requestedExact.stream().map(String::toLowerCase).toList();

        // หา assignee ที่ไม่อยู่ในทีม (เพื่อรายงานกลับ)
        Set<String> notInTeamLower = new LinkedHashSet<>(requestedLower);
        notInTeamLower.removeAll(teamIdsLower);

        // รายการที่ผ่าน (อยู่ในทีม) – เทียบแบบ ignore-case
        List<String> validAssigneesExact = new ArrayList<>();
        for (int i = 0; i < requestedExact.size(); i++) {
            String ex = requestedExact.get(i);
            String lo = requestedLower.get(i);
            if (teamIdsExact.contains(ex) || teamIdsLower.contains(lo)) {
                validAssigneesExact.add(ex);
            }
        }
        if (validAssigneesExact.isEmpty()) {
            throw new BadRequestException("No valid assignees in the team.");
        }

        // ---- resolve assignees to emails ----
        // ดึง candidate จาก User ตาม lower(id/email) เพื่อลดสแกนทั้งตาราง
        Set<String> lowerKeys = validAssigneesExact.stream().map(String::toLowerCase).collect(Collectors.toSet());
        List<User> candidates = em.createQuery("""
                SELECT u FROM User u
                WHERE LOWER(u.id) IN :xs OR LOWER(u.email) IN :xs
                """, User.class)
                .setParameter("xs", lowerKeys)
                .getResultList();

        Map<String, String> idLowerToEmailLower = new HashMap<>();
        Map<String, String> emailLowerToEmailLower = new HashMap<>();
        for (User u : candidates) {
            String idL = safeLower(u.getId() != null ? u.getId().toString() : null);
            String emL = safeLower(u.getEmail());
            if (idL != null && emL != null) idLowerToEmailLower.put(idL, emL);
            if (emL != null) emailLowerToEmailLower.put(emL, emL);
        }

        List<String> assigneeEmails = new ArrayList<>();
        for (String ex : validAssigneesExact) {
            String lo = ex.toLowerCase();
            String email = emailLowerToEmailLower.get(lo);
            if (email == null) email = idLowerToEmailLower.get(lo);
            if (email == null && ex.contains("@")) email = ex.toLowerCase(); // ถ้า ex เป็นอีเมลอยู่แล้ว
            if (email != null) assigneeEmails.add(email);
        }
        // dedup
        assigneeEmails = assigneeEmails.stream().distinct().toList();
        if (assigneeEmails.isEmpty()) throw new BadRequestException("No valid assignee emails found.");

        // ---- validate courses (และหา courseIds ที่หาย) ----
        // dedup courseIds จาก payload ก่อน
        List<String> reqCourseIdsUniq = req.courseIds.stream()
                .filter(Objects::nonNull).map(String::trim).filter(s -> !s.isEmpty())
                .distinct().toList();

        List<LearningContent> contents = em.createQuery("""
            SELECT lc FROM LearningContent lc WHERE lc.id IN :ids
        """, LearningContent.class)
                .setParameter("ids", reqCourseIdsUniq)
                .getResultList();

        Set<String> foundIds = contents.stream().map(LearningContent::getId).collect(Collectors.toSet());
        List<String> missingCourseIds = reqCourseIdsUniq.stream()
                .filter(id -> !foundIds.contains(id))
                .toList();

        if (contents.isEmpty()) throw new BadRequestException("No valid courseIds found.");
        // ใช้เฉพาะที่พบจริง
        List<String> contentIdsUniq = contents.stream().map(LearningContent::getId).distinct().toList();

        // ---- parse due date (ถ้ามี) ----
        LocalDateTime dueAt = null;
        if (notBlank(req.dueDate)) {
            try {
                // ใช้ปลายวัน (23:59:59.999999999) เพื่อไม่ตัดเวลาเร็วเกินไป
                dueAt = LocalDate.parse(req.dueDate).atTime(LocalTime.MAX);
            } catch (Exception e) {
                throw new BadRequestException("Invalid dueDate format, expected YYYY-MM-DD");
            }
        }

        // ---- persist header (ใส่ทุกฟิลด์ NOT NULL ให้ครบ) ----
        AssignmentEntity header = new AssignmentEntity();
        // ถ้า Entity ของคุณมี @GeneratedValue(UUID) แล้ว ไม่จำเป็นต้องเซ็ต id เอง
        header.setId(UUID.randomUUID());
        header.setTeamId(req.teamId);
        header.setCreatedAt(LocalDateTime.now());

        header.setCreaterId(nvl(actorId));
        header.setCreaterEmail(nvl(actorEmail));
        header.setCreaterName(nvl(actorName));
        header.setCreaterAvatar(nvl(actorAvatar)); // สำคัญ: ไม่ปล่อย null

        header.setPriority(notBlank(req.priority) ? req.priority : "Normal");
        header.setNotes(req.note);
        if (dueAt != null) header.setDueDate(dueAt);

        em.persist(header);

        // ---- persist items (de-dup ทั้ง email และ course) ----
        int itemCount = 0;
        for (String email : assigneeEmails) {
            for (String contentId : contentIdsUniq) {
                AssignmentItemEntity item = new AssignmentItemEntity();
                item.setAssignment(header);
                item.setDestinationEmail(email);
                item.setContentId(contentId);
                em.persist(item);
                itemCount++;
            }
        }

        // ---- response ----
        CreateAssignmentResp resp = new CreateAssignmentResp();
        resp.assignmentId    = header.getId().toString();
        resp.assignedCount   = assigneeEmails.size();
        resp.courseCount     = contentIdsUniq.size();
        resp.itemCount       = itemCount;
        resp.ignoredAssignees= new ArrayList<>(notInTeamLower); // รายชื่อ (lowercase) ที่ถูกละทิ้งเพราะไม่อยู่ในทีม
        resp.missingCourseIds= missingCourseIds;                // id ที่หาไม่พบ

        if (!resp.ignoredAssignees.isEmpty()) {
            log.warn("Ignored assignees (not in team {}): {}", req.teamId, resp.ignoredAssignees);
        }
        if (!resp.missingCourseIds.isEmpty()) {
            log.warn("Missing courseIds ignored: {}", resp.missingCourseIds);
        }

        log.info("Assignment created: id={}, assignees={}, courses={}, items={}",
                resp.assignmentId, resp.assignedCount, resp.courseCount, resp.itemCount);

        return Response.status(Response.Status.CREATED).entity(resp).build();
    }

    // ======================= helpers =======================
    private static boolean isBlank(String s) { return s == null || s.isBlank(); }
    private static boolean notBlank(String s) { return s != null && !s.isBlank(); }
    private static String safeLower(String s) { return s == null ? null : s.toLowerCase(); }
    private static String nvl(String s) { return s == null ? "" : s; }

    private static Optional<String> optClaim(JsonWebToken jwt, String name) {
        try {
            Object v = jwt.getClaim(name);
            return Optional.ofNullable(v).map(Object::toString);
        } catch (Exception e) {
            return Optional.empty();
        }
    }
}
