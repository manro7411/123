@PUT
@Path("/{id}")
@Transactional
@RolesAllowed(Roles.ROLE_TRAINER)
public LearningContentDto update(
        @PathParam("id") String id,
        LearningContentDto dto,
        @Context SecurityContext securityContext
) {
    String currentUser = securityContext.getUserPrincipal().getName();
    String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();
    log.info("User '{}' called method '{}' to update Learning content with ID: {}", currentUser, methodName, id);

    LearningContent lc = em.find(LearningContent.class, id);
    if (lc == null) {
        log.error("Learning content with ID: {} not found in method -> {}", id, methodName);
        throw new NotFoundException();
    }

    // ตัวอย่าง ownership check ที่ถูกต้อง (ปรับตาม policy ของระบบ)
    if (lc.getAuthorEmail() != null && !lc.getAuthorEmail().equalsIgnoreCase(currentUser)) {
        log.warn("User '{}' is not owner of content {}, owned by {}", currentUser, id, lc.getAuthorEmail());
        throw new ForbiddenException("You are not allowed to update this learning content");
    }

    /* ==================== อัปเดตข้อมูลพื้นฐาน ==================== */
    if (dto.title() != null) {
        lc.setTitle(dto.title());
        log.info("Updating title to: {} in Method {}", dto.title(), methodName);
    }
    if (dto.description() != null) {
        lc.setDescription(dto.description());
        log.info("Updating description to: {} in Method {}", dto.description(), methodName);
    }
    if (dto.category() != null) {
        lc.setCategory(dto.category());
        log.info("Updating category to: {} in Method {}", dto.category(), methodName);
    }
    if (dto.thumbnailUrl() != null) {
        lc.setThumbnailUrl(dto.thumbnailUrl());
        log.info("Updating thumbnail URL to: {} in Method {}", dto.thumbnailUrl(), methodName);
    }
    if (dto.authorAvatarUrl() != null) {
        lc.setAuthorAvatarUrl(dto.authorAvatarUrl());
        log.info("Updating author avatar URL to: {} in Method {}", dto.authorAvatarUrl(), methodName);
    }
    if (dto.assignType() != null) {
        lc.setAssignType(dto.assignType());
        log.info("Updating assign type to: {} in Method {}", dto.assignType(), methodName);
    }

    if (dto.assignedUserIds() != null) {
        var merged = new LinkedHashSet<>(
                Optional.ofNullable(lc.getAssignedUserIds()).orElseGet(ArrayList::new)
        );
        merged.addAll(dto.assignedUserIds());
        lc.setAssignedUserIds(new ArrayList<>(merged));
    }

    if (dto.assignedTeamIds() != null) {
        var merged = new LinkedHashSet<>(
                Optional.ofNullable(lc.getAssignedTeamIds()).orElseGet(ArrayList::new)
        );
        merged.addAll(dto.assignedTeamIds());
        lc.setAssignedTeamIds(new ArrayList<>(merged));
    }

    if (dto.dueDate() != null) {
        lc.setDueDate(dto.dueDate());
        log.info("Current User -> {} is setting due date to: {} in Method {}", currentUser, dto.dueDate(), methodName);
    }

    /* ==================== อัปเดต Quiz (MULTIPLE + FILL_BLANK) ==================== */

    List<QuestionDTO> dtoQuestions = dto.questions();
    List<QuestionDTO> resultQuestionDtos = new ArrayList<>();

    if (dtoQuestions != null) {
        // เตรียม list คำถามเดิมบน entity
        if (lc.getQuestions() == null) {
            lc.setQuestions(new ArrayList<>());
        }
        List<QuestionEntity> existingQuestions = lc.getQuestions();

        Map<String, QuestionEntity> existingQuestionById = existingQuestions.stream()
                .filter(q -> q.getId() != null)
                .collect(Collectors.toMap(QuestionEntity::getId, q -> q));

        Set<String> keepQuestionIds = new HashSet<>();

        for (QuestionDTO qdto : dtoQuestions) {
            // สมมติ DTO มี field questionId, ถ้าใช้ชื่ออื่นเช่น id ให้ map มา
            String qId = qdto.questionId != null ? qdto.questionId : null;

            QuestionEntity q = null;
            boolean isNewQuestion = false;

            if (qId != null) {
                q = existingQuestionById.get(qId);
                if (q != null) {
                    log.info("Updating existing question ID: {} for content {}", qId, id);
                } else {
                    // มี questionId แต่ไม่มีใน DB -> treat as new (กันกรณี front ส่ง id temp)
                    q = new QuestionEntity();
                    q.setId(generateId());
                    q.setLearningContent(lc);
                    em.persist(q);
                    existingQuestions.add(q);
                    isNewQuestion = true;
                    log.info("Question ID from DTO not found. Created new question ID: {} for content {}", q.getId(), id);
                }
            } else {
                // ไม่มี questionId -> สร้างใหม่
                q = new QuestionEntity();
                q.setId(generateId());
                q.setLearningContent(lc);
                em.persist(q);
                existingQuestions.add(q);
                isNewQuestion = true;
                log.info("Creating new question ID: {} for content {}", q.getId(), id);
            }

            keepQuestionIds.add(q.getId());

            // อัปเดต field พื้นฐาน
            q.setQuestionText(qdto.questionText);
            q.setPoints(qdto.points != null ? qdto.points : 1);

            // resolve type
            QuestionType type = resolveTypeFromDto(qdto);
            q.setType(type);

            /* ---------- MULTIPLE CHOICE ---------- */
            if (type == QuestionType.MULTIPLE) {
                if (q.getChoices() == null) {
                    q.setChoices(new ArrayList<>());
                }
                List<QuestionChoiceEntity> existingChoices = q.getChoices();

                Map<String, QuestionChoiceEntity> choiceById = existingChoices.stream()
                        .filter(c -> c.getId() != null)
                        .collect(Collectors.toMap(QuestionChoiceEntity::getId, c -> c));

                Set<String> keepChoiceIds = new HashSet<>();

                if (qdto.choices != null) {
                    for (ChoiceDTO cdto : qdto.choices) {
                        String cid = cdto.getChoiceId();
                        QuestionChoiceEntity choice;

                        if (cid != null && choiceById.containsKey(cid)) {
                            // อัปเดตตัวเลือกเดิม
                            choice = choiceById.get(cid);
                            log.info("Updating existing choice ID: {} for question ID: {}", cid, q.getId());
                        } else {
                            // เพิ่มตัวเลือกใหม่
                            choice = new QuestionChoiceEntity();

                            // ป้องกันใช้ id ซ้ำ: ถ้า client ส่ง cid มาชน ให้ gen ใหม่
                            String newCid = (cid != null && !choiceById.containsKey(cid))
                                    ? cid
                                    : generateId();

                            choice.setId(newCid);
                            choice.setQuestion(q);
                            em.persist(choice); // persist เฉพาะ entity ใหม่
                            existingChoices.add(choice);
                            log.info("Creating new choice ID: {} for question {}", newCid, q.getId());
                        }

                        keepChoiceIds.add(choice.getId());
                        choice.setChoiceText(cdto.getText());
                        choice.setCorrect(cdto.isCorrect());
                    }
                }

                // ลบ choice ที่ไม่มีใน DTO แล้ว
                for (var it = existingChoices.iterator(); it.hasNext(); ) {
                    QuestionChoiceEntity c = it.next();
                    if (!keepChoiceIds.contains(c.getId())) {
                        log.info("Removing choice ID: {} from question ID: {}", c.getId(), q.getId());
                        em.remove(c);
                        it.remove();
                    }
                }

                // เคลียร์ fill-blank ถ้าเคยมี
                em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                        .setParameter("q", q)
                        .executeUpdate();
            }

            /* ---------- FILL IN THE BLANK ---------- */
            else if (type == QuestionType.FILL_BLANK) {
                // ลบ choices เดิมทั้งหมด (ถ้ามี)
                if (q.getChoices() != null && !q.getChoices().isEmpty()) {
                    for (QuestionChoiceEntity c : new ArrayList<>(q.getChoices())) {
                        em.remove(c);
                    }
                    q.getChoices().clear();
                }

                // จัดการ QuestionFillBlankEntity (1 ต่อ 1 ต่อ question)
                List<QuestionFillBlankEntity> fbList = em.createQuery(
                                "SELECT fb FROM QuestionFillBlankEntity fb WHERE fb.question = :q",
                                QuestionFillBlankEntity.class)
                        .setParameter("q", q)
                        .getResultList();
                QuestionFillBlankEntity fb = fbList.isEmpty() ? null : fbList.get(0);

                String answer = (qdto.correctAnswer != null) ? qdto.correctAnswer.trim() : "";

                if (!answer.isEmpty()) {
                    if (fb == null) {
                        fb = new QuestionFillBlankEntity();
                        fb.setId(generateId());
                        fb.setQuestion(q);
                        em.persist(fb);
                        log.info("Creating fill-blank record ID: {} for question ID: {}", fb.getId(), q.getId());
                    }
                    fb.setCorrectAnswer(answer);
                } else if (fb != null) {
                    // ถ้า DTO ไม่ส่ง correctAnswer แล้ว ให้ลบ record เดิม
                    log.info("Removing fill-blank record ID: {} for question ID: {}", fb.getId(), q.getId());
                    em.remove(fb);
                }
            }

            /* ---------- เผื่อ type อื่นในอนาคต ---------- */
            else {
                // ล้าง choices
                if (q.getChoices() != null && !q.getChoices().isEmpty()) {
                    for (QuestionChoiceEntity c : new ArrayList<>(q.getChoices())) {
                        em.remove(c);
                    }
                    q.getChoices().clear();
                }
                // ล้าง fill-in
                em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                        .setParameter("q", q)
                        .executeUpdate();
            }

            // เก็บ DTO สำหรับใช้ build response
            resultQuestionDtos.add(qdto);

            if (isNewQuestion) {
                log.info("Question ID: {} created/attached to content {}", q.getId(), id);
            } else {
                log.info("Question ID: {} updated for content {}", q.getId(), id);
            }
        }

        // ลบคำถามที่ไม่อยู่ใน DTO แล้ว
        for (var it = existingQuestions.iterator(); it.hasNext(); ) {
            QuestionEntity q = it.next();
            if (!keepQuestionIds.contains(q.getId())) {
                log.info("Removing question ID: {} from content {}", q.getId(), id);

                // ลบ fill-blank ที่ผูกอยู่
                em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                        .setParameter("q", q)
                        .executeUpdate();

                // choices จะถูกลบเพราะ orphanRemoval = true
                em.remove(q);
                it.remove();
            }
        }
    } else {
        log.info("No quiz data provided for content {}, skipping quiz update", id);
    }

    em.flush();
    log.info("Learning content with ID: {} updated successfully in method -> {}", id, methodName);

    return LearningContentDto.withQuizInfo(lc, resultQuestionDtos);
}

/* ==================== Helpers ==================== */

private static String generateId() {
    return UUID.randomUUID().toString().replace("-", "").substring(0, 21);
}

private static QuestionType resolveTypeFromDto(QuestionDTO qdto) {
    if (qdto.type != null) {
        try {
            return QuestionType.valueOf(qdto.type.trim().toUpperCase());
        } catch (IllegalArgumentException ignored) {
        }
    }
    // fallback อัตโนมัติ
    if (qdto.choices != null && !qdto.choices.isEmpty()) {
        return QuestionType.MULTIPLE;
    }
    if (qdto.correctAnswer != null && !qdto.correctAnswer.isBlank()) {
        return QuestionType.FILL_BLANK;
    }
    return QuestionType.MULTIPLE;
}
