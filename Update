ตอนนี้คุณมี sseRef + cleanup แล้ว แต่ StrictMode ยังอาจเปิด-ปิดเร็วมาก ให้ guard อีกชั้น:
function useTrainerQuestionAlerts(token: string | null, trainerEmail: string | null) {
  const startedRef = useRef(false);  // <— เพิ่ม

  useEffect(() => {
    if (!token || !trainerEmail) return;
    if (startedRef.current) return;  // <— กันซ้ำ
    startedRef.current = true;

    // ... ตรงตั้ง SSE ...
    // ... ตั้ง polling ...

    return () => {
      startedRef.current = false;
      // ปิด SSE + clear timer
    };
  }, [token, trainerEmail]);
}


และใน polling เพิ่ม AbortController เหมือนข้อ 1 เพื่อไม่ให้คิวซ้อน:
const pollCtrlRef = useRef<AbortController | null>(null);

const tick = async () => {
  if (!isDocVisible()) { schedule(); return; }

  pollCtrlRef.current?.abort();
  const ctrl = new AbortController();
  pollCtrlRef.current = ctrl;

  try {
    const res = await axios.get<QuestionAlert[]>(POLL_URL, {
      params: { trainer: trainerEmail!.trim().toLowerCase(), since: lastSeenAt.current || undefined, limit: 20 },
      headers: token ? { Authorization: `Bearer ${token}` } : undefined,
      signal: ctrl.signal as any,
    });
    pushToasts(Array.isArray(res.data) ? res.data : []);
  } catch (e: any) {
    if (e.name === "CanceledError" || e.code === "ERR_CANCELED") {
      // ถูกยกเลิกเพราะจะยิงรอบใหม่
    }
  } finally { schedule(); }
};

5) กัน “ข้อมูลขึ้นว่าง” ระหว่างโหลดหลายสาย

สาเหตุบ่อย:

assignment เพิ่งเซ็ต → ไป fetchTeamMembers → selectedTeamId เปลี่ยน → fetchAll ยิงด้วย params ใหม่ทันที ในขณะที่รอบเก่ายังไม่จบ

ตัวกรองฝั่ง client (individual) ทำให้กรองเกลี้ยง

แนวกัน:

ใช้ AbortController (ข้อ 1) → รอบเก่ายกเลิก

ถ้า team mode แต่ selectedTeamId ยังไม่พร้อม → shouldFetch ต้อง false
(คุณทำไว้แล้ว, ดีมาก)

ระหว่างที่กำไม้บังไฟ แสดง skeleton/“Loading…” เฉพาะส่วนกราฟ/ตาราง เพื่อไม่แสดง [] เฉยๆ

นอกจากนี้ ตรวจจุดกรองฝั่ง client:
// ทีมโหมด -> ไม่กรอง client-side
if (mode !== "individual" || selectedUserEmailSet.size === 0) return base;

6) เคส Network 2 ครั้งเพราะ React StrictMode (เฉพาะ DEV)

วิธีง่ายสุดทดสอบ: ลอง ปิด StrictMode ใน main.tsx/index.tsx (เฉพาะ dev) แล้วดู Network tab จะเหลือครั้งเดียว:
// ReactDOM.createRoot(document.getElementById('root')!).render(
//   <React.StrictMode>
//     <App />
//   </React.StrictMode>
// )

ReactDOM.createRoot(document.getElementById('root')!).render(<App />);
