@PUT
@Path("/{id}")
@Transactional
@RolesAllowed(Roles.ROLE_TRAINER)
public LearningContentDto update(
        @PathParam("id") String id,
        LearningContentDto dto,
        @Context SecurityContext securityContext
) {
    String currentUser = securityContext.getUserPrincipal().getName();
    String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();
    log.info("User '{}' called '{}' to update content ID: {}", currentUser, methodName, id);

    LearningContent lc = em.find(LearningContent.class, id);
    if (lc == null) {
        log.error("Learning content with ID {} not found", id);
        throw new NotFoundException();
    }

    // ✅ ตรวจสอบสิทธิ์เจ้าของเนื้อหา
    if (lc.getAuthorEmail() != null && !lc.getAuthorEmail().equalsIgnoreCase(currentUser)) {
        throw new ForbiddenException("You are not allowed to update this learning content");
    }

    /* ========== UPDATE BASIC FIELDS ========== */
    if (dto.title() != null) lc.setTitle(dto.title());
    if (dto.description() != null) lc.setDescription(dto.description());
    if (dto.category() != null) lc.setCategory(dto.category());
    if (dto.thumbnailUrl() != null) lc.setThumbnailUrl(dto.thumbnailUrl());
    if (dto.authorAvatarUrl() != null) lc.setAuthorAvatarUrl(dto.authorAvatarUrl());
    if (dto.assignType() != null) lc.setAssignType(dto.assignType());
    if (dto.dueDate() != null) lc.setDueDate(dto.dueDate());
    if (dto.quizAvailable() != null) lc.setQuizAvailable(dto.quizAvailable());
    else if (dto.questions() != null) lc.setQuizAvailable(Boolean.TRUE);

    // Merge assignedUserIds / assignedTeamIds
    if (dto.assignedUserIds() != null) {
        var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedUserIds()).orElseGet(ArrayList::new));
        merged.addAll(dto.assignedUserIds());
        lc.setAssignedUserIds(new ArrayList<>(merged));
    }
    if (dto.assignedTeamIds() != null) {
        var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedTeamIds()).orElseGet(ArrayList::new));
        merged.addAll(dto.assignedTeamIds());
        lc.setAssignedTeamIds(new ArrayList<>(merged));
    }

    /* ========== UPDATE QUIZ QUESTIONS ========== */
    List<QuestionDTO> dtoQuestions = dto.questions();
    List<QuestionDTO> resultQuestions = new ArrayList<>();

    // โหลดคำถามเดิมทั้งหมด
    List<QuestionEntity> existingQuestions = em.createQuery(
                    "SELECT q FROM QuestionEntity q WHERE q.learningContent.id = :contentId",
                    QuestionEntity.class)
            .setParameter("contentId", id)
            .getResultList();

    Map<String, QuestionEntity> existingById = existingQuestions.stream()
            .filter(q -> q.getId() != null)
            .collect(Collectors.toMap(QuestionEntity::getId, q -> q));

    Set<String> keepIds = new HashSet<>();

    if (dtoQuestions != null && !dtoQuestions.isEmpty()) {
        for (QuestionDTO qdto : dtoQuestions) {
            if (qdto == null) continue;
            String qId = qdto.questionId;
            QuestionEntity question;

            // ✅ ถ้ามี questionId → ใช้ของเดิม
            if (qId != null && existingById.containsKey(qId)) {
                question = existingById.get(qId);
                log.info("Updating existing question {}", qId);
            } else if (qId != null && em.find(QuestionEntity.class, qId) != null) {
                question = em.find(QuestionEntity.class, qId);
            } else {
                // ✅ ถ้าไม่มี questionId → สร้างใหม่
                question = new QuestionEntity();
                String newId = generateId();
                question.setId(newId);
                question.setLearningContent(lc);
                question.setActive(true);
                em.persist(question);
                log.info("Creating new question {} for content {}", newId, id);
            }

            keepIds.add(question.getId());

            // อัปเดต field
            question.setQuestionText(qdto.questionText != null ? qdto.questionText.trim() : "");
            question.setPoints(qdto.points != null ? qdto.points : 1);
            question.setActive(true);

            QuestionType type = resolveTypeFromDto(qdto);
            question.setType(type);

            /* ========== MULTIPLE CHOICE ========== */
            if (type == QuestionType.MULTIPLE) {
                if (question.getChoices() == null) question.setChoices(new ArrayList<>());
                List<QuestionChoiceEntity> existingChoices = question.getChoices();

                Map<String, QuestionChoiceEntity> choiceById = existingChoices.stream()
                        .filter(c -> c.getId() != null)
                        .collect(Collectors.toMap(QuestionChoiceEntity::getId, c -> c));

                Set<String> keepChoices = new HashSet<>();

                if (qdto.choices != null) {
                    for (ChoiceDTO cdto : qdto.choices) {
                        if (cdto == null) continue;
                        String text = cdto.getText();
                        if (text == null || text.trim().isEmpty()) {
                            log.warn("⚠️ Skipping empty choice for question {}", question.getId());
                            continue;
                        }

                        String cid = cdto.getChoiceId();
                        QuestionChoiceEntity choice;

                        if (cid != null && choiceById.containsKey(cid)) {
                            choice = choiceById.get(cid);
                        } else {
                            choice = new QuestionChoiceEntity();
                            choice.setId(cid != null ? cid : generateId());
                            choice.setQuestion(question);
                            em.persist(choice);
                        }

                        choice.setChoiceText(text.trim());
                        choice.setCorrect(cdto.isCorrect());
                        keepChoices.add(choice.getId());
                    }
                }

                // ลบ choice ที่ไม่อยู่ใน DTO
                for (Iterator<QuestionChoiceEntity> it = existingChoices.iterator(); it.hasNext();) {
                    QuestionChoiceEntity c = it.next();
                    if (!keepChoices.contains(c.getId())) {
                        em.remove(c);
                        it.remove();
                    }
                }

                // ลบ fill-blank เก่าถ้ามี
                em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                        .setParameter("q", question)
                        .executeUpdate();
            }

            /* ========== FILL BLANK ========== */
            else if (type == QuestionType.FILL_BLANK) {
                // ลบ choices เดิม
                if (question.getChoices() != null && !question.getChoices().isEmpty()) {
                    for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) {
                        em.remove(c);
                    }
                    question.getChoices().clear();
                }

                List<QuestionFillBlankEntity> fbList = em.createQuery(
                                "SELECT fb FROM QuestionFillBlankEntity fb WHERE fb.question = :q",
                                QuestionFillBlankEntity.class)
                        .setParameter("q", question)
                        .getResultList();

                QuestionFillBlankEntity fb = fbList.isEmpty() ? null : fbList.get(0);
                String ans = qdto.correctAnswer != null ? qdto.correctAnswer.trim() : "";

                if (!ans.isEmpty()) {
                    if (fb == null) {
                        fb = new QuestionFillBlankEntity();
                        fb.setId(generateId());
                        fb.setQuestion(question);
                    }
                    fb.setCorrectAnswer(ans);
                    if (!em.contains(fb)) em.persist(fb);
                } else if (fb != null) {
                    em.remove(fb);
                }
            }

            resultQuestions.add(qdto);
        }

        /* ========== ลบคำถามที่ไม่อยู่ใน DTO (mark inactive) ========== */
        for (QuestionEntity q : existingQuestions) {
            if (!keepIds.contains(q.getId())) {
                log.info("Marking question {} as inactive", q.getId());
                q.setActive(false);
            }
        }
    } else {
        log.info("No questions provided, skipping quiz update");
    }

    em.flush();
    log.info("✅ Content {} updated successfully", id);

    return LearningContentDto.withQuizInfo(lc, resultQuestions);
}
