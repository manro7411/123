@PUT
    @Path("/{id}")
    @Transactional
    @RolesAllowed(Roles.ROLE_TRAINER)
    public LearningContentDto update(@PathParam("id") String id, LearningContentDto dto ,@Context SecurityContext securityContext) {
        String currentUser = securityContext.getUserPrincipal().getName();
        String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();
        log.info("User '{}' called method '{}' to update Learning content with ID: {}", currentUser, methodName, id);
        LearningContent lc = em.find(LearningContent.class, id);

        if (lc == null){
            log.error("Learning content with ID: {} not found in method -> {}", id, methodName);
            throw new NotFoundException();
        }
//        Only Owner for current learning content can update it
        if (lc.getAuthorEmail() != null && lc.getAuthorEmail().equalsIgnoreCase(currentUser)){
            log.info("Current User -> {} is updating learning content owned by: {} in Method {}", currentUser,lc.getAuthorEmail(),methodName);
            throw new ForbiddenException("You are not allowed to update your own learning content");
        }
        if (dto.title() != null){
            lc.setTitle(dto.title());
            log.info("Updating title to: {} in Method {}", dto.title(),methodName);
        }
        if (dto.description() != null){
            lc.setDescription(dto.description());
            log.info("Updating description to: {} in Method {}", dto.description(),methodName);
        }
        if (dto.category()!= null){
            lc.setCategory(dto.category());
            log.info("Updating category to: {} in Method {}", dto.category(),methodName);
        }
        if (dto.thumbnailUrl() != null){
            lc.setThumbnailUrl(dto.thumbnailUrl());
            log.info("Updating thumbnail URL to: {} in Method {}", dto.thumbnailUrl(),methodName);
        }
        if (dto.authorAvatarUrl() != null){
            lc.setAuthorAvatarUrl(dto.authorAvatarUrl());
            log.info("Updating author avatar URL to: {} in Method {}", dto.authorAvatarUrl(),methodName);
        }
        if (dto.assignType() != null){
            lc.setAssignType(dto.assignType());
            log.info("Updating assign type to: {} in Method {}", dto.assignType(),methodName);
        }
        if (dto.assignedUserIds() != null){
            var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedUserIds()).orElseGet(ArrayList::new));
            merged.addAll(dto.assignedUserIds());
            lc.setAssignedUserIds(new ArrayList<>(merged));
        }
        if (dto.assignedTeamIds() != null){
            var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedTeamIds()).orElseGet(ArrayList::new));
            merged.addAll(dto.assignedTeamIds());
            lc.setAssignedTeamIds(new ArrayList<>(merged));

        }
        lc.setAssignedTeamIds(dto.assignedTeamIds());
        if (dto.dueDate() != null) {
            lc.setDueDate(dto.dueDate());
            log.info("Current User -> {} is setting due date to: {} in Method {}", currentUser,dto.dueDate(),methodName);
        }
        List<QuestionDTO> UpdatedQuestion = new ArrayList<>();

        List<QuestionDTO> returnedQuestions = new ArrayList<>();

        if (dto.questions() != null ){
            List<QuestionEntity> existingQuestions = em.createQuery(
                    "SELECT q FROM QuestionEntity q WHERE q.learningContent.id = :contentId",
                    QuestionEntity.class
            ).setParameter("contentId", id).getResultList();
        }
        if (dto.questions() != null){
            for (QuestionDTO isUpdated : dto.questions()){
                QuestionEntity question;

                if(isUpdated.questionId != null){
                    question = em.find(QuestionEntity.class, isUpdated.questionId);
                    if (question != null){
                        log.info("Updating existing question ID: {} for learning content ID: {} in method -> {}", question.getId(), id, methodName);
                    }else {
                        log.info("Question ID: {} not found, creating new question for learning content ID: {} in method -> {}", isUpdated.questionId, id, methodName);
                        question = new QuestionEntity();
                    }
                }else {
                    log.info("Creating new question for learning content ID: {} in method -> {}", id, methodName);
                    question = null;
                }
                if(question != null){
                    log.info("Found existing question ID: {} for learning content ID: {} in method -> {}", question.getId(), id, methodName);
                    question.setQuestionText(isUpdated.questionText);
                    question.setPoints(isUpdated.points != null ? isUpdated.points : 1);
                    question.setType(QuestionType.valueOf(isUpdated.type.toUpperCase()));
                    question.setLearningContent(lc);
                    em.merge(question);
                }else{
                    question = new QuestionEntity();
                    question.setId(UUID.randomUUID().toString().replace("-", "").substring(0, 21));
                    question.setLearningContent(lc);
                    question.setQuestionText(isUpdated.questionText);
                    question.setPoints(isUpdated.points != null ? isUpdated.points : 1);
                    question.setType(QuestionType.valueOf(isUpdated.type.toUpperCase()));
                    em.persist(question);
                    log.info("Created new question ID: {} for learning content ID: {} in method -> {}", question.getId(), id, methodName);
                }
                UpdatedQuestion.add(isUpdated);
                if ("MULTIPLE".equals(isUpdated.type) && isUpdated.choices != null){
                    log.info("Updating Multiple choice question with {} choices for question ID: {} in method -> {}", isUpdated.choices.size(), question.getId(), methodName);
                    for (ChoiceDTO c : isUpdated.choices){
                        QuestionChoiceEntity existingChoice = null;

                        if (c.getChoiceId() != null){ existingChoice = em.find(QuestionChoiceEntity.class, c.getChoiceId());}
                        if (existingChoice != null) {
                            log.info("Updating existing choice ID: {} for question ID: {} in method -> {}", existingChoice.getId(), question.getId(), methodName);
                            existingChoice.setChoiceText(c.getText());
                            existingChoice.setCorrect(c.isCorrect());
                            em.merge(existingChoice);
                        }else {
                            log.info("Adding new choice to question ID: {} in method -> {}", question.getId(), methodName);
                            QuestionChoiceEntity choice = new QuestionChoiceEntity();
                            choice.setId(c.getChoiceId() != null ? c.getChoiceId() : UUID.randomUUID().toString().replace("-", "").substring(0, 21));
                            choice.setChoiceText(c.getText());
                            choice.setCorrect(c.isCorrect());
                            choice.setQuestion(question);
                            em.persist(choice);
                        }
                    }
                }
            }
        }else{
            log.info("Somethings went Wrong with Updated Quiz Info ");
        }
        log.info("Learning content with ID: {} updated successfully in method -> {}", id, methodName);
        return LearningContentDto.withQuizInfo(lc,UpdatedQuestion);
    }
