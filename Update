 Question DTOs in method -> getOne : {"id":"93d572e8f46b4c5f9de82","title":"Additional Quiz Available","description":"Additional Quiz Available","category":"Technical Skills > Cybersecurity","thumbnailUrl":"","authorName":"Nattida Kraisikaj","contentType":"video","authorEmail":"user2@gmail.com","videoUrl":"uploads/video/93d572e8f46b4c5f9de82.mp4","documentUrl":null,"authorAvatarUrl":"uploads/avatars/avatar_UeJ5XJf6np3VVCJcRx_FI.jpg","progressPercent":0,"clickCount":1,"assignType":"all","assignedUserIds":[],"assignedTeamIds":[],"dueDate":null,"quizAvailable":true,"questions":[{"questionId":null,"questionText":"Question1","type":"MULTIPLE","points":1,"choices":[],"correctAnswer":null}]} 

 @PUT
    @Path("/{id}")
    @Transactional
    @RolesAllowed(Roles.ROLE_TRAINER)
    public LearningContentDto update(
            @PathParam("id") String id,
            LearningContentDto dto,
            @Context SecurityContext securityContext
    ) {
        String currentUser = securityContext.getUserPrincipal().getName();
        String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();
        log.info("User '{}' called method '{}' to update Learning content with ID: {}", currentUser, methodName, id);

        LearningContent lc = em.find(LearningContent.class, id);
        if (lc == null) {
            log.error("Learning content with ID: {} not found in method -> {}", id, methodName);
            throw new NotFoundException();
        }

        // อนุญาตเฉพาะเจ้าของ (ปรับตาม policy ได้)
        if (lc.getAuthorEmail() != null && !lc.getAuthorEmail().equalsIgnoreCase(currentUser)) {
            log.warn("User {} is not owner of content {} (owner: {}), forbidden", currentUser, id, lc.getAuthorEmail());
            throw new ForbiddenException("You are not allowed to update this learning content");
        }

        /* ==================== อัปเดตข้อมูลพื้นฐาน ==================== */
        if (dto.title() != null) {
            lc.setTitle(dto.title());
        }
        if (dto.description() != null) {
            lc.setDescription(dto.description());
        }
        if (dto.category() != null) {
            lc.setCategory(dto.category());
        }
        if (dto.thumbnailUrl() != null) {
            lc.setThumbnailUrl(dto.thumbnailUrl());
        }
        if (dto.authorAvatarUrl() != null) {
            lc.setAuthorAvatarUrl(dto.authorAvatarUrl());
        }
        if (dto.assignType() != null) {
            lc.setAssignType(dto.assignType());
        }

        if (dto.assignedUserIds() != null) {
            var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedUserIds()).orElseGet(ArrayList::new));
            merged.addAll(dto.assignedUserIds());
            lc.setAssignedUserIds(new ArrayList<>(merged));
        }

        if (dto.assignedTeamIds() != null) {
            var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedTeamIds()).orElseGet(ArrayList::new));
            merged.addAll(dto.assignedTeamIds());
            lc.setAssignedTeamIds(new ArrayList<>(merged));
        }

        if (dto.dueDate() != null) {
            lc.setDueDate(dto.dueDate());
        }
        if (dto.quizAvailable() != null) {
            lc.setQuizAvailable(dto.quizAvailable());
        }else if (dto.questions() != null){
            lc.setQuizAvailable(Boolean.TRUE);
        }

        /* ==================== อัปเดต Quiz ==================== */

        List<QuestionDTO> dtoQuestions = dto.questions();
        List<QuestionDTO> resultQuestions = new ArrayList<>();

        if (dtoQuestions != null) {
            // โหลดคำถามเดิมทั้งหมดของ content นี้ (managed)
            List<QuestionEntity> existingQuestions = em.createQuery(
                            "SELECT q FROM QuestionEntity q WHERE q.learningContent.id = :contentId",
                            QuestionEntity.class)
                    .setParameter("contentId", id)
                    .getResultList();

            Map<String, QuestionEntity> existingById = existingQuestions.stream()
                    .filter(q -> q.getId() != null)
                    .collect(Collectors.toMap(QuestionEntity::getId, q -> q));

            Set<String> keepQuestionIds = new HashSet<>();

            for (QuestionDTO qdto : dtoQuestions) {
                String qId = qdto.questionId;
                QuestionEntity question;
                boolean isNew = false;
                if (qId != null){
                    QuestionEntity existing = em.find(QuestionEntity.class, qId);
                    if (existing != null) {
                        question = existing;
                        log.info("Reusing existing question ID: {} for content {}", qId, id);
                    } else {
                        question = new QuestionEntity();
                        String newId = generateId();
                        question.setId(newId);
                        question.setLearningContent(lc);
                        lc.setQuizAvailable(Boolean.TRUE);
                        em.persist(question);
                        isNew = true;
                        log.info("Creating new question ID: {} for content {}", newId, id);
                    }
                }else{
                    question = new QuestionEntity();
                    question.setId(generateId());
                    question.setLearningContent(lc);
                    em.persist(question);
                    log.info("Creating new question with new ID: {} for content {}", question.getId(), id);
                }



                keepQuestionIds.add(question.getId());

                // อัปเดต field ของ question
                question.setQuestionText(qdto.questionText);
                question.setPoints(qdto.points != null ? qdto.points : 1);

                QuestionType type = resolveTypeFromDto(qdto);
                question.setType(type);

                /* ========== MULTIPLE CHOICE ========== */
                if (type == QuestionType.MULTIPLE) {
                    if (question.getChoices() == null) {
                        question.setChoices(new ArrayList<>());
                    }
                    List<QuestionChoiceEntity> existingChoices = question.getChoices();

                    Map<String, QuestionChoiceEntity> choiceById = existingChoices.stream()
                            .filter(c -> c.getId() != null)
                            .collect(Collectors.toMap(QuestionChoiceEntity::getId, c -> c));

                    Set<String> keepChoiceIds = new HashSet<>();

                    if (qdto.choices != null) {
                        for (ChoiceDTO cdto : qdto.choices) {
                            String cId = cdto.getChoiceId();
                            QuestionChoiceEntity choice = null;

                            if (cId != null) {
                                choice = choiceById.get(cId);
                                if (choice == null) {
                                    // fallback: ถ้ามีใน DB และ belong กับคำถามนี้ ให้ reuse
                                    QuestionChoiceEntity found = em.find(QuestionChoiceEntity.class, cId);
                                    if (found != null && found.getQuestion() != null &&
                                            question.getId().equals(found.getQuestion().getId())) {
                                        choice = found;
                                        if (!existingChoices.contains(found)) {
                                            existingChoices.add(found);
                                        }
                                    }
                                }
                            }

                            if (choice == null) {
                                choice = new QuestionChoiceEntity();
                                if (cId != null){
                                    QuestionChoiceEntity existingChoice = em.find(QuestionChoiceEntity.class,cId);
                                    log.info("Creating new choice ID: {} for question {}", cId, question.getId());
                                    if (existingChoice != null){
                                        choice = existingChoice;
                                        log.info("Reusing existing choice ID: {} for question {}", cId, question.getId());
                                    }else {
                                        choice.setId(cId);
                                        log.info("Creating new choice ID:{} for question {}", cId, question.getId());
                                    }
                                }else{
                                    choice.setId(generateId());
                                    log.info("Creating new choice ID: {} for question {}", choice.getId(), question.getId());
                                }
                                choice.setQuestion(question);
                                existingChoices.add(choice);

                            }

                            keepChoiceIds.add(choice.getId());
                            choice.setChoiceText(cdto.getText());
                            choice.setCorrect(cdto.isCorrect());
                        }
                    }

                    // ลบ choices ที่ไม่อยู่ใน DTO
                    for (var it = existingChoices.iterator(); it.hasNext(); ) {
                        QuestionChoiceEntity c = it.next();
                        if (!keepChoiceIds.contains(c.getId())) {
                            log.info("Removing choice ID: {} from question {}", c.getId(), question.getId());
                            em.remove(c); // orphanRemoval + remove
                            it.remove();
                        }
                    }

                    // เคลียร์ fill-blank ถ้ามี (กัน type เปลี่ยน)
                    em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                            .setParameter("q", question)
                            .executeUpdate();
                }

                /* ========== FILL IN THE BLANK ========== */
                else if (type == QuestionType.FILL_BLANK) {
                    // ลบ choices เดิมออก
                    if (question.getChoices() != null && !question.getChoices().isEmpty()) {
                        for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) {
                            em.remove(c);
                        }
                        question.getChoices().clear();
                    }

                    // หา fill-blank เดิม
                    List<QuestionFillBlankEntity> fbList = em.createQuery(
                                    "SELECT fb FROM QuestionFillBlankEntity fb WHERE fb.question = :q",
                                    QuestionFillBlankEntity.class)
                            .setParameter("q", question)
                            .getResultList();
                    QuestionFillBlankEntity fb = fbList.isEmpty() ? null : fbList.get(0);

                    String answer = qdto.correctAnswer != null ? qdto.correctAnswer.trim() : "";

                    if (!answer.isEmpty()) {
                        if (fb == null) {
                            fb = new QuestionFillBlankEntity();
                            fb.setId(generateId());
                            fb.setQuestion(question);
                        }
                        fb.setCorrectAnswer(answer); // ตั้งค่าก่อน persist/flush
                        if (!em.contains(fb)) {
                            em.persist(fb);
                            log.info("Creating fill-blank record ID: {} for question {}", fb.getId(), question.getId());
                        }
                    } else if (fb != null) {
                        log.info("Removing fill-blank record ID: {} for question {}", fb.getId(), question.getId());
                        em.remove(fb);
                    }
                }

                /* ========== TYPE อื่น ========== */
                else {
                    // ลบ choices ถ้ามี
                    if (question.getChoices() != null && !question.getChoices().isEmpty()) {
                        for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) {
                            em.remove(c);
                        }
                        question.getChoices().clear();
                    }
                    // ลบ fill-blank ถ้ามี
                    em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                            .setParameter("q", question)
                            .executeUpdate();
                }

                resultQuestions.add(qdto);

                if (isNew) {
                    log.info("Question {} created for content {}", question.getId(), id);
                } else {
                    log.info("Question {} updated for content {}", question.getId(), id);
                }
            }

            // ลบคำถามที่ไม่อยู่ใน DTO (ถ้าไม่มีคำตอบใน quiz_answers เท่านั้น)
            for (QuestionEntity q : existingQuestions) {
                if (!keepQuestionIds.contains(q.getId())) {
                    // เช็คว่ามีคำตอบอ้างอิงอยู่ไหม
                    Number answerCount = (Number) em.createNativeQuery(
                                    "SELECT COUNT(*) FROM quiz_answers WHERE question_id = :qid")
                            .setParameter("qid", q.getId())
                            .getSingleResult();

                    if (answerCount != null && answerCount.longValue() > 0L) {
                        log.warn(
                                "Skip deleting question {} because {} quiz_answers still reference it",
                                q.getId(), answerCount.longValue()
                        );
                        continue; // ห้ามลบคำถามนี้
                    }

                    log.info("Removing question ID: {} from content {}", q.getId(), id);

                    // ลบ fill-blank
                    em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                            .setParameter("q", q)
                            .executeUpdate();

                    // ลบ choices
                    if (q.getChoices() != null && !q.getChoices().isEmpty()) {
                        for (QuestionChoiceEntity c : new ArrayList<>(q.getChoices())) {
                            em.remove(c);
                        }
                        q.getChoices().clear();
                    }

                    em.remove(q);
                }
            }
        } else {
            log.info("No quiz data provided for content {}, skipping quiz update", id);
        }

        em.flush();
        log.info("Learning content with ID: {} updated successfully in {}", id, methodName);

        return LearningContentDto.withQuizInfo(lc, resultQuestions);
    }
