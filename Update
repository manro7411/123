for (QuestionDTO qdto : dtoQuestions) {
    QuestionEntity question = null;
    boolean isNew = false;

    // --- Case: มี questionId และพบในฐานข้อมูล ---
    if (qdto.questionId != null && existingById.containsKey(qdto.questionId)) {
        question = existingById.get(qdto.questionId);
        log.info("Updating existing question ID: {}", qdto.questionId);
    } 
    // --- Case: ไม่มีคำถามเดิม หรือเป็นคำถามใหม่ ---
    else {
        question = new QuestionEntity();
        question.setId(generateId());
        question.setLearningContent(lc);
        em.persist(question);
        isNew = true;
        log.info("Creating new question ID: {} for content {}", question.getId(), id);
    }

    keepQuestionIds.add(question.getId());
    question.setQuestionText(qdto.questionText);
    question.setPoints(qdto.points != null ? qdto.points : 1);

    QuestionType type = resolveTypeFromDto(qdto);
    question.setType(type);

    // ===== MULTIPLE CHOICE =====
    if (type == QuestionType.MULTIPLE) {
        if (question.getChoices() == null)
            question.setChoices(new ArrayList<>());

        List<QuestionChoiceEntity> existingChoices = question.getChoices();
        Map<String, QuestionChoiceEntity> choiceById = existingChoices.stream()
                .filter(c -> c.getId() != null)
                .collect(Collectors.toMap(QuestionChoiceEntity::getId, c -> c));

        Set<String> keepChoiceIds = new HashSet<>();

        if (qdto.choices != null) {
            for (ChoiceDTO cdto : qdto.choices) {
                QuestionChoiceEntity choice = null;

                // --- ถ้ามี choiceId และอยู่ใน existing ---
                if (cdto.getChoiceId() != null && choiceById.containsKey(cdto.getChoiceId())) {
                    choice = choiceById.get(cdto.getChoiceId());
                } 
                // --- ถ้าเป็น choice ใหม่ ---
                else {
                    choice = new QuestionChoiceEntity();
                    choice.setId(generateId());
                    choice.setQuestion(question);
                    existingChoices.add(choice);
                    em.persist(choice);
                    log.info("Creating new choice ID: {} for question {}", choice.getId(), question.getId());
                }

                keepChoiceIds.add(choice.getId());
                choice.setChoiceText(cdto.getText());
                choice.setCorrect(cdto.isCorrect());
            }
        }

        // --- ลบ choice ที่ไม่มีใน DTO ---
        for (Iterator<QuestionChoiceEntity> it = existingChoices.iterator(); it.hasNext();) {
            QuestionChoiceEntity c = it.next();
            if (!keepChoiceIds.contains(c.getId())) {
                em.remove(c);
                it.remove();
                log.info("Removed old choice ID: {}", c.getId());
            }
        }

        // ล้าง fill-blanks เก่า
        em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                .setParameter("q", question)
                .executeUpdate();
    }
    // ===== FILL BLANK =====
    else if (type == QuestionType.FILL_BLANK) {
        // ลบ choices เดิม
        if (question.getChoices() != null) {
            for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) em.remove(c);
            question.getChoices().clear();
        }

        // สร้างหรืออัปเดต fill-blank
        List<QuestionFillBlankEntity> fbList = em.createQuery(
                        "SELECT fb FROM QuestionFillBlankEntity fb WHERE fb.question = :q",
                        QuestionFillBlankEntity.class)
                .setParameter("q", question)
                .getResultList();

        QuestionFillBlankEntity fb = fbList.isEmpty() ? null : fbList.get(0);
        String answer = Optional.ofNullable(qdto.correctAnswer).map(String::trim).orElse("");

        if (!answer.isEmpty()) {
            if (fb == null) {
                fb = new QuestionFillBlankEntity();
                fb.setId(generateId());
                fb.setQuestion(question);
            }
            fb.setCorrectAnswer(answer);
            if (!em.contains(fb)) em.persist(fb);
        } else if (fb != null) {
            em.remove(fb);
        }
    }

    // ===== CLEANUP OTHER TYPES =====
    else {
        if (question.getChoices() != null) {
            for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) em.remove(c);
            question.getChoices().clear();
        }
        em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                .setParameter("q", question)
                .executeUpdate();
    }

    if (isNew) log.info("Question {} created for content {}", question.getId(), id);
    else log.info("Question {} updated for content {}", question.getId(), id);
}



@PUT
@Path("/{id}")
@Transactional
@RolesAllowed(Roles.ROLE_TRAINER)
public LearningContentDto update(
        @PathParam("id") String id,
        LearningContentDto dto,
        @Context SecurityContext securityContext
) {
    String currentUser = securityContext.getUserPrincipal().getName();
    String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();
    log.info("User '{}' called method '{}' to update LearningContent ID: {}", currentUser, methodName, id);

    LearningContent lc = em.find(LearningContent.class, id);
    if (lc == null) {
        log.error("LearningContent with ID: {} not found", id);
        throw new NotFoundException();
    }

    // ===== Ownership check =====
    if (lc.getAuthorEmail() != null && !lc.getAuthorEmail().equalsIgnoreCase(currentUser)) {
        log.warn("User {} is not owner of content {} (owner: {}), forbidden", currentUser, id, lc.getAuthorEmail());
        throw new ForbiddenException("You are not allowed to update this learning content");
    }

    // ===== Update basic info =====
    if (dto.title() != null) lc.setTitle(dto.title());
    if (dto.description() != null) lc.setDescription(dto.description());
    if (dto.category() != null) lc.setCategory(dto.category());
    if (dto.thumbnailUrl() != null) lc.setThumbnailUrl(dto.thumbnailUrl());
    if (dto.authorAvatarUrl() != null) lc.setAuthorAvatarUrl(dto.authorAvatarUrl());
    if (dto.assignType() != null) lc.setAssignType(dto.assignType());
    if (dto.dueDate() != null) lc.setDueDate(dto.dueDate());
    if (dto.quizAvailable() != null) lc.setQuizAvailable(dto.quizAvailable());
    else if (dto.questions() != null) lc.setQuizAvailable(Boolean.TRUE);

    if (dto.assignedUserIds() != null) {
        var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedUserIds()).orElseGet(ArrayList::new));
        merged.addAll(dto.assignedUserIds());
        lc.setAssignedUserIds(new ArrayList<>(merged));
    }
    if (dto.assignedTeamIds() != null) {
        var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedTeamIds()).orElseGet(ArrayList::new));
        merged.addAll(dto.assignedTeamIds());
        lc.setAssignedTeamIds(new ArrayList<>(merged));
    }

    // ===== Update quiz =====
    List<QuestionDTO> dtoQuestions = dto.questions();
    if (dtoQuestions != null) {
        List<QuestionEntity> existingQuestions = em.createQuery(
                        "SELECT q FROM QuestionEntity q WHERE q.learningContent.id = :cid",
                        QuestionEntity.class)
                .setParameter("cid", id)
                .getResultList();

        Map<String, QuestionEntity> existingById = existingQuestions.stream()
                .filter(q -> q.getId() != null)
                .collect(Collectors.toMap(QuestionEntity::getId, q -> q));

        Set<String> keepQuestionIds = new HashSet<>();

        for (QuestionDTO qdto : dtoQuestions) {
            QuestionEntity question;
            boolean isNew = false;

            // ===== Create or update question =====
            if (qdto.questionId != null && existingById.containsKey(qdto.questionId)) {
                question = existingById.get(qdto.questionId);
                log.info("Updating existing question ID: {}", qdto.questionId);
            } else {
                question = new QuestionEntity();
                question.setId(generateId());
                question.setLearningContent(lc);
                em.persist(question);
                isNew = true;
                log.info("Creating new question ID: {} for content {}", question.getId(), id);
            }

            keepQuestionIds.add(question.getId());
            question.setQuestionText(qdto.questionText);
            question.setPoints(qdto.points != null ? qdto.points : 1);
            QuestionType type = resolveTypeFromDto(qdto);
            question.setType(type);

            // ===== MULTIPLE CHOICE =====
            if (type == QuestionType.MULTIPLE) {
                if (question.getChoices() == null)
                    question.setChoices(new ArrayList<>());

                List<QuestionChoiceEntity> existingChoices = question.getChoices();
                Map<String, QuestionChoiceEntity> choiceById = existingChoices.stream()
                        .filter(c -> c.getId() != null)
                        .collect(Collectors.toMap(QuestionChoiceEntity::getId, c -> c));

                Set<String> keepChoiceIds = new HashSet<>();

                if (qdto.choices != null) {
                    for (ChoiceDTO cdto : qdto.choices) {
                        QuestionChoiceEntity choice = null;

                        if (cdto.getChoiceId() != null && choiceById.containsKey(cdto.getChoiceId())) {
                            choice = choiceById.get(cdto.getChoiceId());
                        } else {
                            choice = new QuestionChoiceEntity();
                            choice.setId(generateId());
                            choice.setQuestion(question);
                            existingChoices.add(choice);
                            em.persist(choice);
                            log.info("Creating new choice ID: {} for question {}", choice.getId(), question.getId());
                        }

                        keepChoiceIds.add(choice.getId());
                        choice.setChoiceText(cdto.getText());
                        choice.setCorrect(cdto.isCorrect());
                    }
                }

                // Remove old choices
                for (Iterator<QuestionChoiceEntity> it = existingChoices.iterator(); it.hasNext(); ) {
                    QuestionChoiceEntity c = it.next();
                    if (!keepChoiceIds.contains(c.getId())) {
                        em.remove(c);
                        it.remove();
                        log.info("Removed old choice ID: {}", c.getId());
                    }
                }

                // Clean up fill blanks
                em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                        .setParameter("q", question)
                        .executeUpdate();
            }

            // ===== FILL IN THE BLANK =====
            else if (type == QuestionType.FILL_BLANK) {
                if (question.getChoices() != null) {
                    for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) em.remove(c);
                    question.getChoices().clear();
                }

                List<QuestionFillBlankEntity> fbList = em.createQuery(
                                "SELECT fb FROM QuestionFillBlankEntity fb WHERE fb.question = :q",
                                QuestionFillBlankEntity.class)
                        .setParameter("q", question)
                        .getResultList();

                QuestionFillBlankEntity fb = fbList.isEmpty() ? null : fbList.get(0);
                String answer = Optional.ofNullable(qdto.correctAnswer).map(String::trim).orElse("");

                if (!answer.isEmpty()) {
                    if (fb == null) {
                        fb = new QuestionFillBlankEntity();
                        fb.setId(generateId());
                        fb.setQuestion(question);
                    }
                    fb.setCorrectAnswer(answer);
                    if (!em.contains(fb)) em.persist(fb);
                } else if (fb != null) {
                    em.remove(fb);
                }
            }

            // ===== OTHER TYPES =====
            else {
                if (question.getChoices() != null) {
                    for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) em.remove(c);
                    question.getChoices().clear();
                }
                em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                        .setParameter("q", question)
                        .executeUpdate();
            }

            if (isNew)
                log.info("Question {} created for content {}", question.getId(), id);
            else
                log.info("Question {} updated for content {}", question.getId(), id);
        }

        // ===== Remove questions not in DTO =====
        for (QuestionEntity q : existingQuestions) {
            if (!keepQuestionIds.contains(q.getId())) {
                Number answerCount = (Number) em.createNativeQuery(
                                "SELECT COUNT(*) FROM quiz_answers WHERE question_id = :qid")
                        .setParameter("qid", q.getId())
                        .getSingleResult();

                if (answerCount.longValue() > 0L) {
                    log.warn("Skipping delete of question {} - still referenced by {} quiz_answers",
                            q.getId(), answerCount.longValue());
                    continue;
                }

                log.info("Removing question ID: {} from content {}", q.getId(), id);
                em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                        .setParameter("q", q)
                        .executeUpdate();

                if (q.getChoices() != null) {
                    for (QuestionChoiceEntity c : new ArrayList<>(q.getChoices())) em.remove(c);
                    q.getChoices().clear();
                }
                em.remove(q);
            }
        }
    } else {
        log.info("No quiz data provided for content {}, skipping quiz update", id);
    }

    // ===== Final flush =====
    em.flush();

    List<QuestionEntity> updatedQuestions = em.createQuery(
                    "SELECT q FROM QuestionEntity q LEFT JOIN FETCH q.choices WHERE q.learningContent.id = :cid ORDER BY q.createdAt ASC",
                    QuestionEntity.class)
            .setParameter("cid", id)
            .getResultList();

    List<QuestionDTO> questionDtos = updatedQuestions.stream()
            .map(this::mapToDto)
            .collect(Collectors.toList());

    log.info("LearningContent {} updated successfully with {} questions", id, questionDtos.size());
    return LearningContentDto.withQuizInfo(lc, questionDtos);
}
