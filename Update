2025-10-30 09:53:26,692 ERROR [io.qua.ver.htt.run.QuarkusErrorHandler] (executor-thread-1) HTTP Request to /trainer/content-performance?start=2025-10-24&end=2025-10-30&view=team&teamId=3fbf03f3013f42d2b9402&userEmail=BO3-4M9zL_3-2ZLS0syuu&order=learners:desc&limit=50&offset=0 failed, error id: f79818b9-07d9-4e10-b582-ec6c83428c9a-47

Exception in TrainerAnalyticResources.java:318
          316  
          317          @SuppressWarnings("unchecked")                                                                                                                                                                               
        ? 318          List<Object[]> rows = q.getResultList();                                                                                                                                                                     
          319                                                                                                                                                                                                                       
          320          // ---------- Learner details (��ͧ����͹ main) ----------                                                                                                                                                     

Exception in TrainerAnalyticResources.java:318
          316                                                                                                                                                                                                                       
          317          @SuppressWarnings("unchecked")                                                                                                                                                                               
        ? 318          List<Object[]> rows = q.getResultList();                                                                                                                                                                     
          319                                                                                                                                                                                                                       
          320          // ---------- Learner details (��ͧ����͹ main) ----------: org.hibernate.exception.SQLGrammarException: JDBC exception executing SQL [    SELECT                                                              
      lc.id AS content_id,                                                                                                                                                                                                          
      lc.title AS title,                                                                                                                                                                                                            
      COUNT(DISTINCT p.user_email) AS learners,                                                                                                                                                                                     
      AVG(CASE WHEN p.percent = 100 THEN 1.0 ELSE 0.0 END) AS completion_rate,                                                                                                                                                      
      AVG(p.score) AS avg_score                                                                                                                                                                                                     
    FROM learning_content lc                                                                                                                                                                                                        
    LEFT JOIN user_lesson_progress p ON p.lesson_id = lc.id                                                                                                                                                                         
      AND (                                                                                                                                                                                                                         
           (p.started_at   IS NOT NULL AND p.started_at   >= ? AND p.started_at   < ?)                                                                                                                                              
        OR (p.completed_at IS NOT NULL AND p.completed_at >= ? AND p.completed_at < ?)                                                                                                                                              
      )                                                                                                                                                                                                                             
      AND LOWER(p.user_email) = ?                                                                                                                                                                                                   
    WHERE lc.team_id = ?                                                                                                                                                                                                            
    GROUP BY lc.id, lc.title                                                                                                                                                                                                        
    ORDER BY learners DESC fetch first ? rows only                                                                                                                                                                                  
] [ERROR: column lc.team_id does not exist                                                                                                                                                                                          
  Position: 555] [n/a]                                                                                                                                                                                                              
        at org.hibernate.exception.internal.SQLStateConversionDelegate.convert(SQLStateConversionDelegate.java:91)                                                                                                                  
        at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:58)                                                                                                            
        at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:108)                                                                                                                                    
        at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:94)                                                                                                                                     
        at org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess.executeQuery(DeferredResultSetAccess.java:269)                                                                                                           
        at org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess.getResultSet(DeferredResultSetAccess.java:172)                                                                                                           
        at org.hibernate.sql.results.jdbc.internal.AbstractResultSetAccess.getMetaData(AbstractResultSetAccess.java:36)                                                                                                             
        at org.hibernate.sql.results.jdbc.internal.AbstractResultSetAccess.getColumnCount(AbstractResultSetAccess.java:52)                                                                                                          
        at org.hibernate.query.results.ResultSetMappingImpl.resolve(ResultSetMappingImpl.java:194)                                                                                                                                  
        at org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.resolveJdbcValuesSource(JdbcSelectExecutorStandardImpl.java:340)                                                                                          
        at org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.doExecuteQuery(JdbcSelectExecutorStandardImpl.java:137)                                                                                                   
        at org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.executeQuery(JdbcSelectExecutorStandardImpl.java:102)                                                                                                     
        at org.hibernate.sql.exec.spi.JdbcSelectExecutor.executeQuery(JdbcSelectExecutor.java:91)                                                                                                                                   
        at org.hibernate.sql.exec.spi.JdbcSelectExecutor.list(JdbcSelectExecutor.java:165)                                                                                                                                          
        at org.hibernate.sql.exec.spi.JdbcSelectExecutor.list(JdbcSelectExecutor.java:142)                                                                                                                                          
        at org.hibernate.sql.exec.spi.JdbcSelectExecutor.list(JdbcSelectExecutor.java:132)                                                                                                                                          
        at org.hibernate.query.sql.internal.NativeSelectQueryPlanImpl.performList(NativeSelectQueryPlanImpl.java:135)                                                                                                               
        at org.hibernate.query.sql.internal.NativeQueryImpl.doList(NativeQueryImpl.java:697)                                                                                                                                        
        at org.hibernate.query.spi.AbstractSelectionQuery.list(AbstractSelectionQuery.java:143)                                                                                                                                     
        at org.hibernate.query.Query.getResultList(Query.java:120)                                                                                                                                                                  
        at TrainerAnalytic.Resources.TrainerAnalyticResources.contentPerformance(TrainerAnalyticResources.java:318)                                                                                                                 
        at TrainerAnalytic.Resources.TrainerAnalyticResources_Subclass.contentPerformance$$superforward(Unknown Source)                                                                                                             
        at TrainerAnalytic.Resources.TrainerAnalyticResources_Subclass$$function$$14.apply(Unknown Source)                                                                                                                          
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:73)                                                                                                                         
        at io.quarkus.arc.impl.AroundInvokeInvocationContext$NextAroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:97)                                                                                       
        at io.quarkus.security.runtime.interceptor.SecurityHandler.handle(SecurityHandler.java:27)                                                                                                                                  
        at io.quarkus.security.runtime.interceptor.RolesAllowedInterceptor.intercept(RolesAllowedInterceptor.java:29)                                                                                                               
        at io.quarkus.security.runtime.interceptor.RolesAllowedInterceptor_Bean.intercept(Unknown Source)                                                                                                                           
        at io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:42)                                                                                                                                          
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:70)                                                                                                                         
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:62)                                                                                                                         
        at io.quarkus.resteasy.reactive.server.runtime.StandardSecurityCheckInterceptor.intercept(StandardSecurityCheckInterceptor.java:44)                                                                                         
        at io.quarkus.resteasy.reactive.server.runtime.StandardSecurityCheckInterceptor_RolesAllowedInterceptor_Bean.intercept(Unknown Source)                                                                                      
        at io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:42)                                                                                                                                          
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.perform(AroundInvokeInvocationContext.java:30)                                                                                                                         
        at io.quarkus.arc.impl.InvocationContexts.performAroundInvoke(InvocationContexts.java:27)                                                                                                                                   
        at TrainerAnalytic.Resources.TrainerAnalyticResources_Subclass.contentPerformance(Unknown Source)                                                                                                                           
        at TrainerAnalytic.Resources.TrainerAnalyticResources$quarkusrestinvoker$contentPerformance_6e652322075c378f8dbe169c9f842f6afe4d9dcb.invoke(Unknown Source)                                                                 
        at org.jboss.resteasy.reactive.server.handlers.InvocationHandler.handle(InvocationHandler.java:29)                                                                                                                          
        at io.quarkus.resteasy.reactive.server.runtime.QuarkusResteasyReactiveRequestContext.invokeHandler(QuarkusResteasyReactiveRequestContext.java:141)                                                                          
        at org.jboss.resteasy.reactive.common.core.AbstractResteasyReactiveContext.run(AbstractResteasyReactiveContext.java:147)                                                                                                    
        at io.quarkus.vertx.core.runtime.VertxCoreRecorder$15.runWith(VertxCoreRecorder.java:637)                                                                                                                                   
        at org.jboss.threads.EnhancedQueueExecutor$Task.doRunWith(EnhancedQueueExecutor.java:2651)                                                                                                                                  
        at org.jboss.threads.EnhancedQueueExecutor$Task.run(EnhancedQueueExecutor.java:2630)                                                                                                                                        
        at org.jboss.threads.EnhancedQueueExecutor.runThreadBody(EnhancedQueueExecutor.java:1622)                                                                                                                                   
        at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1589)                                                                                                                                  
        at org.jboss.threads.DelegatingRunnable.run(DelegatingRunnable.java:11)                                                                                                                                                     
        at org.jboss.threads.ThreadLocalResettingRunnable.run(ThreadLocalResettingRunnable.java:11)                                                                                                                                 
        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)                                                                                                                                    
        at java.base/java.lang.Thread.run(Thread.java:1583)                                                                                                                                                                         
Caused by: org.postgresql.util.PSQLException: ERROR: column lc.team_id does not exist                                                                                                                                               
  Position: 555                                                                                                                                                                                                                     
        at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2736)                                                                                                                               
        at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2423)                                                                                                                                     
        at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:374)                                                                                                                                             
        at org.postgresql.jdbc.PgStatement.executeInternal(PgStatement.java:518)                                                                                                                                                    
        at org.postgresql.jdbc.PgStatement.execute(PgStatement.java:435)                                                                                                                                                            
        at org.postgresql.jdbc.PgPreparedStatement.executeWithFlags(PgPreparedStatement.java:196)                                                                                                                                   
        at org.postgresql.jdbc.PgPreparedStatement.executeQuery(PgPreparedStatement.java:139)                                                                                                                                       
        at io.agroal.pool.wrapper.PreparedStatementWrapper.executeQuery(PreparedStatementWrapper.java:80)                                                                                                                           
        at org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess.executeQuery(DeferredResultSetAccess.java:251)     


























package TrainerAnalytic.Resources;

import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;
import model.TeamEntity;
import model.User;
import org.acme.security.jwt.Roles;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Trainer Analytics endpoints
 *
 * Base path: /trainer
 */
@Path("/trainer")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class TrainerAnalyticResources {

    private static final Logger log = LoggerFactory.getLogger(TrainerAnalyticResources.class);

    @Inject EntityManager em;
    @Inject TrainerUtilities trainerUtilities;

    // ===== Helpers =====
    private static LocalDate parseDateOr(String s, LocalDate fallback) {
        if (s == null || s.isBlank()) return fallback;
        return LocalDate.parse(s);
    }
    private static LocalDateTime startOfDay(LocalDate d) { return d.atStartOfDay(); }
    private static LocalDateTime dayAfter(LocalDate d) { return d.plusDays(1).atStartOfDay(); }

    /** Resolve trainer email from token principal */
    private String resolveTrainerEmail(SecurityContext sc) {
        String email = (sc.getUserPrincipal() != null) ? sc.getUserPrincipal().getName() : null;
        if (email == null || email.isBlank()) {
            throw new WebApplicationException("Missing principal", Response.Status.UNAUTHORIZED);
        }
        return email.toLowerCase();
    }

    // =========================================================================
    // 1) OVERVIEW (รองรับ view=team|individual + teamId + userEmail)
    // =========================================================================
    @GET
    @Path("/overview")
    @RolesAllowed({Roles.ROLE_TRAINER, Roles.ROLE_ADMINISTRATOR})
    public Response overview(
            @Context SecurityContext securityContext,
            @QueryParam("start") String start,
            @QueryParam("end") String end,
            @QueryParam("view") @DefaultValue("individual") String view,
            @QueryParam("teamId") String teamId,
            @QueryParam("userEmail") String userEmail // <-- NEW (optional)
    ) {
        final String trainerEmail = resolveTrainerEmail(securityContext);
        final LocalDate endDate = parseDateOr(end, LocalDate.now());
        final LocalDate startDate = parseDateOr(start, endDate.minusDays(6));
        final LocalDateTime startDT = startOfDay(startDate);
        final LocalDateTime endDT = dayAfter(endDate);

        final boolean isTeamView = "team".equalsIgnoreCase(view);
        final boolean filterUser = (userEmail != null && !userEmail.isBlank());
        final String userEmailNorm = filterUser ? userEmail.trim().toLowerCase() : null;

        log.info("[trainer/overview] email={} view={} teamId={} userEmail={} window {}..(exclusive {})",
                trainerEmail, view, teamId, userEmailNorm, startDT, endDT);

        // Filter by content ownership (team หรือ ผู้แต่ง)
        final String contentFilter = isTeamView ? "lc.team_id = :teamId" : "lc.author_email = :email";

        // Helper: bind base filters
        java.util.function.Consumer<Query> bindBase = q -> {
            q.setParameter("start", startDT).setParameter("end", endDT);
            if (isTeamView) q.setParameter("teamId", teamId);
            else q.setParameter("email", trainerEmail);
            if (filterUser) q.setParameter("userEmail", userEmailNorm);
        };

        // ---------- KPI: total contents ----------
        String totalContentSql = "SELECT COUNT(*) FROM learning_content lc WHERE " + contentFilter;
        Query totalContentQuery = em.createNativeQuery(totalContentSql);
        if (isTeamView) totalContentQuery.setParameter("teamId", teamId);
        else totalContentQuery.setParameter("email", trainerEmail);
        long totalContents = ((Number) totalContentQuery.getSingleResult()).longValue();

        // ---------- KPI: active learners ----------
        String activeLearnersSql = String.format("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND (
                  (p.started_at   IS NOT NULL AND p.started_at   >= :start AND p.started_at   < :end)
               OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
              )
              %s
        """, contentFilter, filterUser ? "AND LOWER(p.user_email) = :userEmail" : "");
        Query activeLearnersQuery = em.createNativeQuery(activeLearnersSql);
        bindBase.accept(activeLearnersQuery);
        long activeLearners = ((Number) activeLearnersQuery.getSingleResult()).longValue();

        // ---------- KPI: new enrollments ----------
        String newEnrollmentsSql = String.format("""
            SELECT COUNT(*)
            FROM user_lesson_progress p
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND p.started_at IS NOT NULL
              AND p.started_at >= :start AND p.started_at < :end
              %s
        """, contentFilter, filterUser ? "AND LOWER(p.user_email) = :userEmail" : "");
        Query newEnrollmentsQuery = em.createNativeQuery(newEnrollmentsSql);
        bindBase.accept(newEnrollmentsQuery);
        long newEnrollments = ((Number) newEnrollmentsQuery.getSingleResult()).longValue();

        // ---------- KPI: completion rate & avg score ----------
        String rateSql = String.format("""
            SELECT
              AVG(CASE WHEN p.percent = 100 THEN 1.0 ELSE 0.0 END),
              AVG(p.score)
            FROM user_lesson_progress p
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND (
                  (p.started_at   IS NOT NULL AND p.started_at   >= :start AND p.started_at   < :end)
               OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
              )
              %s
        """, contentFilter, filterUser ? "AND LOWER(p.user_email) = :userEmail" : "");
        Query rateQuery = em.createNativeQuery(rateSql);
        bindBase.accept(rateQuery);
        Object[] rateRow = (Object[]) rateQuery.getSingleResult();
        double completionRate = rateRow[0] == null ? 0d : ((Number) rateRow[0]).doubleValue();
        Double avgScore = rateRow[1] == null ? null : ((Number) rateRow[1]).doubleValue();

        // ---------- Trend: enroll detail per day ----------
        String enrollDetailSql = String.format("""
            SELECT DATE(p.started_at), u.name, p.user_email, lc.title, p.started_at
            FROM user_lesson_progress p
            JOIN users u ON u.email = p.user_email
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND p.started_at IS NOT NULL
              AND p.started_at >= :start AND p.started_at < :end
              %s
        """, contentFilter, filterUser ? "AND LOWER(p.user_email) = :userEmail" : "");
        Query enrollDetailQuery = em.createNativeQuery(enrollDetailSql);
        bindBase.accept(enrollDetailQuery);
        List<Object[]> enrollDetails = enrollDetailQuery.getResultList();

        // ---------- Trend: complete detail per day ----------
        String completeDetailSql = String.format("""
            SELECT DATE(p.completed_at), u.name, p.user_email, lc.title, p.score, p.total_questions, p.completed_at
            FROM user_lesson_progress p
            JOIN users u ON u.email = p.user_email
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND p.completed_at IS NOT NULL
              AND p.completed_at >= :start AND p.completed_at < :end
              %s
        """, contentFilter, filterUser ? "AND LOWER(p.user_email) = :userEmail" : "");
        Query completeDetailQuery = em.createNativeQuery(completeDetailSql);
        bindBase.accept(completeDetailQuery);
        List<Object[]> completeDetails = completeDetailQuery.getResultList();

        // ---------- Merge trend ----------
        Map<LocalDate, Map<String, List<Map<String, Object>>>> trendMap = new LinkedHashMap<>();
        for (LocalDate d = startDate; !d.isAfter(endDate); d = d.plusDays(1)) {
            Map<String, List<Map<String, Object>>> daily = new HashMap<>();
            daily.put("enroll", new ArrayList<>());
            daily.put("complete", new ArrayList<>());
            trendMap.put(d, daily);
        }

        for (Object[] r : enrollDetails) {
            LocalDate d = ((java.sql.Date) r[0]).toLocalDate();
            if (trendMap.containsKey(d)) {
                Map<String, Object> user = Map.of(
                        "name", r[1],
                        "email", r[2],
                        "course", r[3],
                        "startedAt", r[4]
                );
                trendMap.get(d).get("enroll").add(user);
            }
        }

        for (Object[] r : completeDetails) {
            LocalDate d = ((java.sql.Date) r[0]).toLocalDate();
            if (trendMap.containsKey(d)) {
                Map<String, Object> user = Map.of(
                        "name", r[1],
                        "email", r[2],
                        "course", r[3],
                        "score", r[4],
                        "totalQuestions", r[5],
                        "CompletedAt", r[6]
                );
                trendMap.get(d).get("complete").add(user);
            }
        }

        List<Map<String, Object>> trend = new ArrayList<>();
        trendMap.forEach((date, data) -> {
            Map<String, Object> row = new LinkedHashMap<>();
            row.put("date", date.toString());
            row.put("enrollCount", data.get("enroll").size());
            row.put("completeCount", data.get("complete").size());
            row.put("enroll", data.get("enroll"));
            row.put("complete", data.get("complete"));
            trend.add(row);
        });

        Map<String, Object> kpi = new LinkedHashMap<>();
        kpi.put("totalContents", totalContents);
        kpi.put("newEnrollments", newEnrollments);
        kpi.put("completionRate", completionRate);
        kpi.put("avgScore", avgScore);

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("kpi", kpi);
        out.put("trend", trend);

        return Response.ok(out).build();
    }

    // =========================================================================
    // 2) CONTENT PERFORMANCE (รองรับ view + teamId + userEmail)
    // =========================================================================
    @GET
    @Path("/content-performance")
    @RolesAllowed({Roles.ROLE_TRAINER, Roles.ROLE_ADMINISTRATOR})
    public Response contentPerformance(
            @Context SecurityContext securityContext,
            @QueryParam("start") String start,
            @QueryParam("end") String end,
            @QueryParam("order") @DefaultValue("completionRate:desc") String order,
            @QueryParam("limit") @DefaultValue("20") int limit,
            @QueryParam("offset") @DefaultValue("0") int offset,
            @QueryParam("view") @DefaultValue("individual") String view,     // <-- NEW
            @QueryParam("teamId") String teamId,                              // <-- NEW
            @QueryParam("userEmail") String userEmail                         // <-- NEW
    ) {
        final String trainerEmail = resolveTrainerEmail(securityContext);
        final LocalDate endDate = parseDateOr(end, LocalDate.now());
        final LocalDate startDate = parseDateOr(start, endDate.minusDays(6));
        final LocalDateTime startDT = startOfDay(startDate);
        final LocalDateTime endDT = dayAfter(endDate);

        if (limit < 1) limit = 20;
        if (limit > 200) limit = 200;
        if (offset < 0) offset = 0;

        final boolean isTeamView = "team".equalsIgnoreCase(view);
        final boolean filterUser = (userEmail != null && !userEmail.isBlank());
        final String userEmailNorm = filterUser ? userEmail.trim().toLowerCase() : null;

        String orderSql = "completion_rate DESC";
        if (order != null && !order.isBlank()) {
            String[] parts = order.split(":");
            String field = parts[0];
            String dir = parts.length > 1 ? parts[1] : "asc";
            String sortDir = "desc".equalsIgnoreCase(dir) ? "DESC" : "ASC";
            switch (field) {
                case "title" -> orderSql = "lc.title " + sortDir;
                case "learners" -> orderSql = "learners " + sortDir;
                case "avgScore" -> orderSql = "avg_score " + sortDir;
                case "completionRate" -> orderSql = "completion_rate " + sortDir;
            }
        }

        // Ownership filter (ทีม/ผู้แต่ง)
        final String contentFilter = isTeamView ? "lc.team_id = :teamId" : "lc.author_email = :email";

        // ---------- Main content performance ----------
        String sql = ("""
            SELECT
              lc.id AS content_id,
              lc.title AS title,
              COUNT(DISTINCT p.user_email) AS learners,
              AVG(CASE WHEN p.percent = 100 THEN 1.0 ELSE 0.0 END) AS completion_rate,
              AVG(p.score) AS avg_score
            FROM learning_content lc
            LEFT JOIN user_lesson_progress p ON p.lesson_id = lc.id
              AND (
                   (p.started_at   IS NOT NULL AND p.started_at   >= :start AND p.started_at   < :end)
                OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
              )
              %s
            WHERE %s
            GROUP BY lc.id, lc.title
            ORDER BY %s
        """).formatted(filterUser ? "AND LOWER(p.user_email) = :userEmail" : "", contentFilter, orderSql);

        Query q = em.createNativeQuery(sql)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (isTeamView) q.setParameter("teamId", teamId); else q.setParameter("email", trainerEmail);
        if (filterUser) q.setParameter("userEmail", userEmailNorm);
        q.setFirstResult(offset);
        q.setMaxResults(limit);

        @SuppressWarnings("unchecked")
        List<Object[]> rows = q.getResultList();

        // ---------- Learner details (กรองเหมือน main) ----------
        List<String> contentIds = rows.stream().map(r -> String.valueOf(r[0])).toList();
        List<Map<String, Object>> items = new ArrayList<>(rows.size());

        if (!contentIds.isEmpty()) {
            String learnerSql = ("""
                SELECT
                  p.lesson_id AS content_id,
                  u.name AS learner_name,
                  p.user_email,
                  p.percent,
                  p.score
                FROM user_lesson_progress p
                JOIN users u ON u.email = p.user_email
                JOIN learning_content lc ON lc.id = p.lesson_id
                WHERE p.lesson_id IN :contentIds
                  AND (
                       (p.started_at   IS NOT NULL AND p.started_at   >= :start AND p.started_at   < :end)
                    OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
                  )
                  %s
                  AND %s
            """).formatted(filterUser ? "AND LOWER(p.user_email) = :userEmail" : "", contentFilter);

            Query learnerQuery = em.createNativeQuery(learnerSql)
                    .setParameter("contentIds", contentIds)
                    .setParameter("start", startDT)
                    .setParameter("end", endDT);
            if (filterUser) learnerQuery.setParameter("userEmail", userEmailNorm);
            if (isTeamView) learnerQuery.setParameter("teamId", teamId); else learnerQuery.setParameter("email", trainerEmail);

            @SuppressWarnings("unchecked")
            List<Object[]> learnerRows = learnerQuery.getResultList();

            Map<String, List<Map<String, Object>>> learnersByContent = new HashMap<>();
            for (Object[] r : learnerRows) {
                String cid = String.valueOf(r[0]);
                Map<String, Object> learner = new LinkedHashMap<>();
                learner.put("name", r[1]);
                learner.put("email", r[2]);
                learner.put("percent", r[3]);
                learner.put("score", r[4]);
                learnersByContent.computeIfAbsent(cid, k -> new ArrayList<>()).add(learner);
            }

            for (Object[] r : rows) {
                String cid = String.valueOf(r[0]);
                Map<String, Object> m = new LinkedHashMap<>();
                m.put("contentId", cid);
                m.put("title", r[1]);
                m.put("learnersCount", ((Number) (r[2] == null ? 0 : r[2])).longValue());
                m.put("completionRate", r[3] == null ? 0d : ((Number) r[3]).doubleValue());
                m.put("avgScore", r[4] == null ? null : ((Number) r[4]).doubleValue());
                m.put("learners", learnersByContent.getOrDefault(cid, List.of()));
                items.add(m);
            }
        }

        Number total = (Number) em.createNativeQuery("""
            SELECT COUNT(*) FROM learning_content lc WHERE %s
        """.formatted(contentFilter))
                .setParameter(isTeamView ? "teamId" : "email", isTeamView ? teamId : trainerEmail)
                .getSingleResult();

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("items", items);
        out.put("total", total.longValue());
        out.put("limit", limit);
        out.put("offset", offset);
        return Response.ok(out).build();
    }

    // =========================================================================
    // 3) CONTENT FUNNEL (เดิม)
    // =========================================================================
    @GET
    @Path("/content-funnel")
    @RolesAllowed({Roles.ROLE_TRAINER,Roles.ROLE_ADMINISTRATOR})
    public Response contentFunnel(
            @Context SecurityContext securityContext,
            @QueryParam("contentId") String contentId,
            @QueryParam("start") String start,
            @QueryParam("end")   String end
    ) {
        if (contentId == null || contentId.isBlank()) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(Map.of("error", "Missing contentId")).build();
        }
        final String trainerEmail = resolveTrainerEmail(securityContext);
        final LocalDate endDate   = parseDateOr(end, LocalDate.now());
        final LocalDate startDate = parseDateOr(start, endDate.minusDays(6));
        final LocalDateTime startDT = startOfDay(startDate);
        final LocalDateTime endDT   = dayAfter(endDate);

        Number owned = (Number) em.createNativeQuery("""
            SELECT COUNT(*) FROM learning_content lc WHERE lc.id = :cid AND lc.author_email = :email
        """).setParameter("cid", contentId)
                .setParameter("email", trainerEmail)
                .getSingleResult();
        if (owned.intValue() == 0) {
            return Response.status(Response.Status.FORBIDDEN)
                    .entity(Map.of("error","Content not owned by trainer")).build();
        }

        Number enrolled = (Number) em.createNativeQuery("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            WHERE p.lesson_id = :cid
              AND p.started_at IS NOT NULL
              AND p.started_at >= :start AND p.started_at < :end
        """).setParameter("cid", contentId)
                .setParameter("start", startDT)
                .setParameter("end", endDT)
                .getSingleResult();

        Number half = (Number) em.createNativeQuery("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            WHERE p.lesson_id = :cid
              AND p.percent >= 50
              AND (
                   (p.started_at  IS NOT NULL AND p.started_at  >= :start AND p.started_at  < :end)
                OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
              )
        """).setParameter("cid", contentId)
                .setParameter("start", startDT)
                .setParameter("end", endDT)
                .getSingleResult();

        Number completed = (Number) em.createNativeQuery("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            WHERE p.lesson_id = :cid
              AND p.completed_at IS NOT NULL
              AND p.completed_at >= :start AND p.completed_at < :end
        """).setParameter("cid", contentId)
                .setParameter("start", startDT)
                .setParameter("end", endDT)
                .getSingleResult();

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("contentId", contentId);
        out.put("funnel", Map.of(
                "enrolled",  enrolled.longValue(),
                "started",   enrolled.longValue(),
                "half",      half.longValue(),
                "completed", completed.longValue()
        ));
        return Response.ok(out).build();
    }
}
