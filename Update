@PUT
    @Path("/{id}")
    @Transactional
    @RolesAllowed(Roles.ROLE_TRAINER)
    public LearningContentDto update(
            @PathParam("id") String id,
            LearningContentDto dto,
            @Context SecurityContext securityContext
    ) {
        String currentUser = securityContext.getUserPrincipal().getName();
        String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();
        log.info("User '{}' called method '{}' to update Learning content with ID: {}", currentUser, methodName, id);

        LearningContent lc = em.find(LearningContent.class, id);
        if (lc == null) {
            log.error("Learning content with ID: {} not found in method -> {}", id, methodName);
            throw new NotFoundException();
        }

        // อนุญาตเฉพาะเจ้าของ (ปรับตาม policy ได้)
        if (lc.getAuthorEmail() != null && !lc.getAuthorEmail().equalsIgnoreCase(currentUser)) {
            log.warn("User {} is not owner of content {} (owner: {}), forbidden", currentUser, id, lc.getAuthorEmail());
            throw new ForbiddenException("You are not allowed to update this learning content");
        }

        /* ==================== อัปเดตข้อมูลพื้นฐาน ==================== */
        if (dto.title() != null) {
            lc.setTitle(dto.title());
        }
        if (dto.description() != null) {
            lc.setDescription(dto.description());
        }
        if (dto.category() != null) {
            lc.setCategory(dto.category());
        }
        if (dto.thumbnailUrl() != null) {
            lc.setThumbnailUrl(dto.thumbnailUrl());
        }
        if (dto.authorAvatarUrl() != null) {
            lc.setAuthorAvatarUrl(dto.authorAvatarUrl());
        }
        if (dto.assignType() != null) {
            lc.setAssignType(dto.assignType());
        }

        if (dto.assignedUserIds() != null) {
            var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedUserIds()).orElseGet(ArrayList::new));
            merged.addAll(dto.assignedUserIds());
            lc.setAssignedUserIds(new ArrayList<>(merged));
        }

        if (dto.assignedTeamIds() != null) {
            var merged = new LinkedHashSet<>(Optional.ofNullable(lc.getAssignedTeamIds()).orElseGet(ArrayList::new));
            merged.addAll(dto.assignedTeamIds());
            lc.setAssignedTeamIds(new ArrayList<>(merged));
        }
        if (dto.maxAttempts() != null){
            lc.setMaxAttempts(dto.maxAttempts());
        }

        if (dto.dueDate() != null) {
            lc.setDueDate(dto.dueDate());
        }
        if (dto.quizAvailable() != null) {
            lc.setQuizAvailable(dto.quizAvailable());
        }else if (dto.questions() != null){
            lc.setQuizAvailable(Boolean.TRUE);
        }


        /* ==================== อัปเดต Quiz ==================== */

        List<QuestionDTO> dtoQuestions = dto.questions();
        List<QuestionDTO> resultQuestions = new ArrayList<>();

        if (dtoQuestions != null) {
            // โหลดคำถามเดิมทั้งหมดของ content นี้ (managed)
            List<QuestionEntity> existingQuestions = em.createQuery(
                            "SELECT q FROM QuestionEntity q WHERE q.learningContent.id = :contentId",
                            QuestionEntity.class)
                    .setParameter("contentId", id)
                    .getResultList();

            Map<String, QuestionEntity> existingById = existingQuestions.stream()
                    .filter(q -> q.getId() != null)
                    .collect(Collectors.toMap(QuestionEntity::getId, q -> q));

            Set<String> keepQuestionIds = new HashSet<>();

            for (QuestionDTO qdto : dtoQuestions) {
                String qId = qdto.questionId;
                QuestionEntity question;
                boolean isNew = false;
                if (qId != null){
                    QuestionEntity existing = em.find(QuestionEntity.class, qId);
                    if (existing != null) {
                        question = existing;
                        log.info("Reusing existing question ID: {} for content {}", qId, id);
                    } else {
                        question = new QuestionEntity();
                        String newId = generateId();
                        question.setId(newId);
                        question.setLearningContent(lc);
                        lc.setQuizAvailable(Boolean.TRUE);
                        em.persist(question);
                        isNew = true;
                        log.info("Creating new question ID: {} for content {}", newId, id);
                    }
                }else{
                    question = new QuestionEntity();
                    String newId = generateId();
                    question.setId(newId);
                    question.setLearningContent(lc);
                    em.persist(question);
                    em.flush();
                    log.info("Creating new question with new ID: {} for content {}", newId, id);
                }



                keepQuestionIds.add(question.getId());

                // อัปเดต field ของ question
                question.setQuestionText(qdto.questionText);
                question.setPoints(qdto.points != null ? qdto.points : 1);

                QuestionType type = resolveTypeFromDto(qdto);
                question.setType(type);

                /* ========== MULTIPLE CHOICE ========== */
                if (type == QuestionType.MULTIPLE) {
                    if (question.getChoices() == null) {
                        question.setChoices(new ArrayList<>());
                    }
                    List<QuestionChoiceEntity> existingChoices = question.getChoices();

                    Map<String, QuestionChoiceEntity> choiceById = existingChoices.stream()
                            .filter(c -> c.getId() != null)
                            .collect(Collectors.toMap(QuestionChoiceEntity::getId, c -> c));

                    Set<String> keepChoiceIds = new HashSet<>();

                    if (qdto.choices != null) {
                        for (ChoiceDTO cdto : qdto.choices) {
                            String cId = cdto.getChoiceId();
                            QuestionChoiceEntity choice = null;

                            if (cId != null) {
                                choice = choiceById.get(cId);
                                if (choice == null) {
                                    // fallback: ถ้ามีใน DB และ belong กับคำถามนี้ ให้ reuse
                                    QuestionChoiceEntity found = em.find(QuestionChoiceEntity.class, cId);
                                    if (found != null && found.getQuestion() != null &&
                                            question.getId().equals(found.getQuestion().getId())) {
                                        choice = found;
                                        if (!existingChoices.contains(found)) {
                                            existingChoices.add(found);
                                        }
                                    }
                                }
                            }

                            if (choice == null) {
                                choice = new QuestionChoiceEntity();
                                if (cId != null){
                                    QuestionChoiceEntity existingChoice = em.find(QuestionChoiceEntity.class,cId);
                                    log.info("Creating new choice ID: {} for question {}", cId, question.getId());
                                    if (existingChoice != null){
                                        choice = existingChoice;
                                        log.info("Reusing existing choice ID: {} for question {}", cId, question.getId());
                                    }else {
                                        choice.setId(cId);
                                        log.info("Creating new choice ID:{} for question {}", cId, question.getId());
                                    }
                                }else{
                                    choice.setId(generateId());
                                    log.info("Creating new choice ID: {} for question {}", choice.getId(), question.getId());
                                }
                                choice.setQuestion(question);
                                existingChoices.add(choice);

                            }

                            keepChoiceIds.add(choice.getId());
                            choice.setChoiceText(cdto.getText());
                            choice.setCorrect(cdto.isCorrect());
                        }
                    }

                    // ลบ choices ที่ไม่อยู่ใน DTO
                    for (var it = existingChoices.iterator(); it.hasNext(); ) {
                        QuestionChoiceEntity c = it.next();
                        if (!keepChoiceIds.contains(c.getId())) {
                            log.info("Removing choice ID: {} from question {}", c.getId(), question.getId());
                            em.remove(c); // orphanRemoval + remove
                            it.remove();
                        }
                    }

                    // เคลียร์ fill-blank ถ้ามี (กัน type เปลี่ยน)
                    em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                            .setParameter("q", question)
                            .executeUpdate();
                }

                /* ========== FILL IN THE BLANK ========== */
                else if (type == QuestionType.FILL_BLANK) {
                    // ลบ choices เดิมออก
                    if (question.getChoices() != null && !question.getChoices().isEmpty()) {
                        for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) {
                            em.remove(c);
                        }
                        question.getChoices().clear();
                    }

                    // หา fill-blank เดิม
                    List<QuestionFillBlankEntity> fbList = em.createQuery(
                                    "SELECT fb FROM QuestionFillBlankEntity fb WHERE fb.question = :q",
                                    QuestionFillBlankEntity.class)
                            .setParameter("q", question)
                            .getResultList();
                    QuestionFillBlankEntity fb = fbList.isEmpty() ? null : fbList.get(0);

                    String answer = qdto.correctAnswer != null ? qdto.correctAnswer.trim() : "";

                    if (!answer.isEmpty()) {
                        if (fb == null) {
                            fb = new QuestionFillBlankEntity();
                            fb.setId(generateId());
                            fb.setQuestion(question);
                        }
                        fb.setCorrectAnswer(answer); // ตั้งค่าก่อน persist/flush
                        if (!em.contains(fb)) {
                            em.persist(fb);
                            log.info("Creating fill-blank record ID: {} for question {}", fb.getId(), question.getId());
                        }
                    } else if (fb != null) {
                        log.info("Removing fill-blank record ID: {} for question {}", fb.getId(), question.getId());
                        em.remove(fb);
                    }
                }

                /* ========== TYPE อื่น ========== */
                else {
                    // ลบ choices ถ้ามี
                    if (question.getChoices() != null && !question.getChoices().isEmpty()) {
                        for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) {
                            em.remove(c);
                        }
                        question.getChoices().clear();
                    }
                    // ลบ fill-blank ถ้ามี
                    em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                            .setParameter("q", question)
                            .executeUpdate();
                }

                resultQuestions.add(qdto);

                if (isNew) {
                    log.info("Question {} created for content {}", question.getId(), id);
                } else {
                    log.info("Question {} updated for content {}", question.getId(), id);
                }
            }

            // ลบคำถามที่ไม่อยู่ใน DTO (ถ้าไม่มีคำตอบใน quiz_answers เท่านั้น)
            for (QuestionEntity q : existingQuestions) {
                if (!keepQuestionIds.contains(q.getId())) {
                    // เช็คว่ามีคำตอบอ้างอิงอยู่ไหม
                    Number answerCount = (Number) em.createNativeQuery(
                                    "SELECT COUNT(*) FROM quiz_answers WHERE question_id = :qid")
                            .setParameter("qid", q.getId())
                            .getSingleResult();

                    if (answerCount != null && answerCount.longValue() > 0L) {
                        log.warn(
                                "Skip deleting question {} because {} quiz_answers still reference it",
                                q.getId(), answerCount.longValue()
                        );
                        continue; // ห้ามลบคำถามนี้
                    }

                    log.info("Removing question ID: {} from content {}", q.getId(), id);

                    // ลบ fill-blank
                    em.createQuery("DELETE FROM QuestionFillBlankEntity fb WHERE fb.question = :q")
                            .setParameter("q", q)
                            .executeUpdate();

                    // ลบ choices
                    if (q.getChoices() != null && !q.getChoices().isEmpty()) {
                        for (QuestionChoiceEntity c : new ArrayList<>(q.getChoices())) {
                            em.remove(c);
                        }
                        q.getChoices().clear();
                    }

                    em.remove(q);
                }
            }
        } else {
            log.info("No quiz data provided for content {}, skipping quiz update", id);
        }

        em.flush();
        log.info("Learning content with ID: {} updated successfully in {}", id, methodName);

        return LearningContentDto.withQuizInfo(lc, resultQuestions);
    }

/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useContext, useEffect, useMemo, useRef, useState } from "react";
import { createPortal } from "react-dom";
import { X, Save, Plus, Trash2 } from "lucide-react";
import { TARGET_OPTION } from "../AdminUtil";
import type { QuestionForm } from "../../../types/trainer/types";
import { AuthContext } from "../../../Authentication/AuthContext";
import { CATEGORY_GROUP } from "../../../types/base/types";

/* ---------------------------------------------------------------------------
 * Types
 * -------------------------------------------------------------------------*/
export interface Lesson {
  id: number | string;
  title: string;
  thumbnailUrl?: string;
  category: string;
  description: string;
  contentType: "video" | "document";
  assignType: "all" | "team" | "specific";
  quizAvailable?: boolean;
  maxAttempts: number;
}

interface EditLessonModalProps {
  open: boolean;
  initial: Lesson;
  onClose: () => void;
  onSave: (data: {
    title: string;
    category: string;
    description: string;
    thumbnailUrl?: string;
    video?: File | null;
    contentType: "video" | "document";
    assignType: "all" | "team" | "specific";
    quizAvailable: boolean;
    maxAttempts: number;
    questions?: QuestionForm[];
  }) => Promise<void> | void;
}

type Choice = { choiceId?: string; text: string; correct?: boolean };
type QuestionTypeUI = "MULTIPLE" | "FILL_BLANK";

type Q = {
  questionId?: string;
  questionText: string;
  type: QuestionTypeUI;
  choices: Choice[];
  correctAnswer?: string;
  points?: number;
};

/* ---------------------------------------------------------------------------
 * Helpers
 * -------------------------------------------------------------------------*/
const emptyChoice = (): Choice => ({ text: "", correct: false });
const emptyMultiple = (): Q => ({
  questionText: "",
  type: "MULTIPLE",
  choices: [emptyChoice(), emptyChoice()],
  points: 1,
});

const normalizeContentType = (t: any): "video" | "document" =>
  String(t || "video").toLowerCase() === "document" ? "document" : "video";

/* ---------------------------------------------------------------------------
 * Component
 * -------------------------------------------------------------------------*/
const EditLessonModal = ({ open, initial, onClose, onSave }: EditLessonModalProps) => {
  const { token } = useContext(AuthContext);

  const [title, setTitle] = useState(initial.title);
  const [, setCategory] = useState(initial.category);
  const [maxAttempts, setMaxAttempts] = useState<number>(initial.maxAttempts);
  const [description, setDescription] = useState(initial.description);
  const [thumbnailUrl, setThumbnailUrl] = useState(initial.thumbnailUrl ?? "");
  const [videoFile, setVideoFile] = useState<File | null>(null);
  const [contentType, setContentType] = useState<"video" | "document">("video");
  const [assignType, setAssignType] = useState<"all" | "specific" | "team">("all");
  const [saving, setSaving] = useState(false);
  const [quizAvailable, setQuizAvailable] = useState(initial.quizAvailable ?? false);
  const [questions, setQuestions] = useState<Q[]>([]);
  const [loading, setLoading] = useState(false);

  const [categoryGroup, setCategoryGroup] = useState<string>("");
  const [categorySub, setCategorySub] = useState<string>();
  const categoryValue = categorySub ? `${categoryGroup} > ${categorySub}` : categoryGroup;

  /* ---------------- Reset when `initial` changes ---------------- */
  useEffect(() => {
    setTitle(initial.title);

    let grp = "";
    let sub: string | undefined = "";
    if (initial.category) {
      if (initial.category.includes(">")) {
        const parts = initial.category.split(">").map((s) => s.trim());
        grp = parts[0] ?? "";
        sub = parts[1] ?? "";
      } else {
        for (const g of Object.keys(CATEGORY_GROUP)) {
          if ((CATEGORY_GROUP[g] || []).includes(initial.category)) {
            grp = g;
            sub = initial.category;
            break;
          }
        }
        if (!grp) {
          grp = initial.category;
          sub = "";
        }
      }
    }
    setCategory(initial.category);
    setCategoryGroup(grp);
    setCategorySub(sub);
    setDescription(initial.description);
    setThumbnailUrl(initial.thumbnailUrl ?? "");
    setContentType(initial.contentType ?? "video");
    setAssignType(initial.assignType ?? "all");
    setQuizAvailable(initial.quizAvailable ?? false);
    setMaxAttempts(initial.maxAttempts);

    // clear local questions; will be reloaded when modal opens
    setQuestions([]);
  }, [initial]);

  /* ---------------- Load lesson detail (and questions) ---------------- */
  useEffect(() => {
    if (!open) return;
    if (!initial?.id) return;

    const ctrl = new AbortController();
    const doFetch = async () => {
      setLoading(true);
      try {
        const url = `/api/learning/${encodeURIComponent(String(initial.id))}`;
        const res = await fetch(url, {
          headers: token ? { Authorization: `Bearer ${token}` } : undefined,
          cache: "no-store",
          signal: ctrl.signal,
        });
        if (!res.ok) {
          // eslint-disable-next-line no-console
          console.error("EditLessonModal: fetch failed", res.status, await res.text().catch(() => ""));
          return;
        }
        const data = await res.json();

        setTitle(data.title ?? "");
        setCategory(data.category ?? "");
        setDescription(data.description ?? "");
        setThumbnailUrl(data.thumbnailUrl ?? "");
        setContentType(normalizeContentType(data.contentType));
        setAssignType(data.assignType ?? "all");
        setQuizAvailable(Boolean(data.quizAvailable));

        const qs: Q[] = Array.isArray(data.questions)
          ? data.questions.map((q: any): Q => {
              const backendType = (q.type || "").toString().toUpperCase();
              const isFill = backendType === "FILL_BLANK";

              if (isFill) {
                return {
                  questionId: q.questionId ?? q.id,
                  questionText: q.questionText ?? q.text ?? "",
                  type: "FILL_BLANK",
                  choices: [],
                  correctAnswer: q.correctAnswer ?? "",
                  points: q.points ?? 1,
                };
              }

              const normalizedChoices: Choice[] = Array.isArray(q.choices)
                ? q.choices.map((c: any) => ({
                    choiceId: c.choiceId ?? c.id,
                    text: c.text ?? c.choiceText ?? "",
                    correct: Boolean(c.correct ?? c.isCorrect ?? false),
                  }))
                : [];

              return {
                questionId: q.questionId ?? q.id,
                questionText: q.questionText ?? q.text ?? "",
                type: "MULTIPLE",
                choices: normalizedChoices.length >= 2 ? normalizedChoices : [emptyChoice(), emptyChoice()],
                points: q.points ?? 1,
              };
            })
          : [];

        setQuestions(qs);
      } catch (e: any) {
        if (e?.name !== "AbortError") {
          // eslint-disable-next-line no-console
          console.error("Failed to fetch lesson details:", e);
        }
      } finally {
        setLoading(false);
      }
    };
    doFetch();

    return () => ctrl.abort();
  }, [open, initial.id, token]);

  /* ---------------- Question editors ---------------- */
  const addQuestion = () => setQuestions((s) => [...s, emptyMultiple()]);

  const removeQuestion = (idx: number) => setQuestions((s) => s.filter((_, i) => i !== idx));

  const updateQuestionText = (idx: number, text: string) =>
    setQuestions((s) => s.map((q, i) => (i === idx ? { ...q, questionText: text } : q)));

  const updateQuestionType = (idx: number, type: QuestionTypeUI) =>
    setQuestions((s) =>
      s.map((q, i) => {
        if (i !== idx) return q;
        if (q.type === type) return q;

        if (type === "MULTIPLE") {
          const choices = q.choices && q.choices.length >= 2 ? q.choices : [emptyChoice(), emptyChoice()];
          return { ...q, type: "MULTIPLE", choices, correctAnswer: undefined };
        }
        return { ...q, type: "FILL_BLANK", correctAnswer: q.correctAnswer ?? "", choices: [] };
      })
    );

  const updateQuestionPoints = (idx: number, points: number) =>
    setQuestions((s) => s.map((q, i) => (i === idx ? { ...q, points } : q)));

  const addChoice = (qIdx: number) =>
    setQuestions((s) => s.map((q, i) => (i === qIdx ? { ...q, choices: [...q.choices, emptyChoice()] } : q)));

  const removeChoice = (qIdx: number, cIdx: number) =>
    setQuestions((s) =>
      s.map((q, i) => (i === qIdx ? { ...q, choices: q.choices.filter((_, ci) => ci !== cIdx) } : q))
    );

  const updateChoiceText = (qIdx: number, cIdx: number, text: string) =>
    setQuestions((s) =>
      s.map((q, i) =>
        i === qIdx
          ? { ...q, choices: q.choices.map((c, ci) => (ci === cIdx ? { ...c, text } : c)) }
          : q
      )
    );

  const toggleChoiceCorrect = (qIdx: number, cIdx: number) =>
    setQuestions((s) =>
      s.map((q, i) => {
        if (i !== qIdx) return q;
        return {
          ...q,
          choices: q.choices.map((c, ci) => (ci === cIdx ? { ...c, correct: !c.correct } : c)),
        };
      })
    );

  const updateFillBlankAnswer = (qIdx: number, value: string) =>
    setQuestions((s) => s.map((q, i) => (i === qIdx ? { ...q, correctAnswer: value } : q)));

  /* ---------------- Submit ---------------- */
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSaving(true);
    try {
      // Build questions for backend (IMPORTANT: map questionId/choiceId -> id)
      let payloadQuestions: QuestionForm[] | undefined = undefined;

      if (quizAvailable) {
        const cleaned: any[] = [];
        const removedIndices: number[] = [];

        for (let i = 0; i < questions.length; i++) {
          const q = questions[i];
          const qText = (q.questionText || "").trim();
          if (!qText) {
            removedIndices.push(i + 1);
            continue;
          }

          if (q.type === "FILL_BLANK") {
            const answer = (q.correctAnswer || "").trim();
            if (!answer) {
              removedIndices.push(i + 1);
              continue;
            }
            cleaned.push({
              id: q.questionId || undefined, // <-- map
              questionText: qText,
              type: "FILL_BLANK",
              correctAnswer: answer,
              points: q.points ?? 1,
            });
            continue;
          }

          // MULTIPLE
          const cleanedChoices = (q.choices || [])
            .map((c) => ({ ...c, text: String(c.text || "").trim() }))
            .filter((c) => c.text.length > 0);

          if (cleanedChoices.length < 2) {
            removedIndices.push(i + 1);
            continue;
          }
          if (!cleanedChoices.some((c) => !!c.correct)) {
            removedIndices.push(i + 1);
            continue;
          }

          cleaned.push({
            id: q.questionId || undefined, // <-- map
            questionText: qText,
            type: "MULTIPLE",
            points: q.points ?? 1,
            choices: cleanedChoices.map((c) => ({
              id: c.choiceId || undefined, // <-- map
              text: c.text,
              correct: !!c.correct,
            })),
          });
        }

        if (removedIndices.length) {
          alert(`Removed invalid/empty questions: ${removedIndices.join(", ")}`);
        }

        // Reflect cleaned content back to UI (optional)
        setQuestions((prev) => {
          const newQs: Q[] = cleaned.map((cq: any) =>
            cq.type === "FILL_BLANK"
              ? {
                  questionId: cq.id,
                  questionText: cq.questionText,
                  type: "FILL_BLANK",
                  choices: [],
                  correctAnswer: cq.correctAnswer,
                  points: cq.points,
                }
              : {
                  questionId: cq.id,
                  questionText: cq.questionText,
                  type: "MULTIPLE",
                  points: cq.points,
                  choices: (cq.choices || []).map((c: any) => ({
                    choiceId: c.id,
                    text: c.text,
                    correct: !!c.correct,
                  })),
                }
          );
          return newQs.length ? newQs : prev;
        });

        payloadQuestions = cleaned.length ? (cleaned as QuestionForm[]) : undefined;
      }

      const payload = {
        title: title.trim(),
        category: categoryValue,
        description: description.trim(),
        thumbnailUrl: thumbnailUrl.trim() || undefined,
        video: videoFile,
        contentType,
        assignType: assignType as "all" | "team" | "specific",
        quizAvailable,
        maxAttempts,
        questions: payloadQuestions,
      };

      await onSave(payload);
    } finally {
      setSaving(false);
    }
  };

  if (!open) return null;

  const stop = (e: React.MouseEvent) => e.stopPropagation();

  /* ---------------- UI ---------------- */
  const modal = (
    <div
      className="fixed inset-0 bg-black/50 z-[9999] flex items-center justify-center p-4"
      onClick={onClose}
      aria-modal="true"
      role="dialog"
    >
      <div
        className="bg-white rounded-xl shadow-xl w-full max-w-3xl p-6 overflow-auto max-h-[90vh]"
        onClick={stop}
      >
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-lg font-semibold">Edit Learning Content</h2>
          <button onClick={onClose} className="text-gray-500 hover:text-gray-700" type="button" aria-label="Close">
            <X size={18} />
          </button>
        </div>

        {loading ? (
          <div className="p-6 text-sm text-gray-500">Loading lesson...</div>
        ) : (
          <form className="space-y-4" onSubmit={handleSubmit}>
            {/* Title & MaxAttempts */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Title</label>
                <input
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  className="w-full border rounded-lg px-3 py-2"
                  placeholder="Lesson title"
                  required
                  disabled={saving}
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Max Attempts</label>
                <input
                  value={maxAttempts}
                  onChange={(e) => setMaxAttempts(Math.max(1, Math.min(3, Number(e.target.value) || 1)))}
                  min={1}
                  max={3}
                  className="w-full border rounded-lg px-3 py-2"
                  placeholder="1 - 3"
                  disabled={saving}
                  type="number"
                />
              </div>

              {/* Category */}
              <div className="space y-4">
                <div className="flex items-center gap-2">
                  <label className="block text-sm font-medium text-gray-700">Category:</label>
                  <select
                    value={categoryGroup}
                    onChange={(e) => {
                      setCategoryGroup(e.target.value);
                      setCategorySub("");
                    }}
                    className="border rounded px-2 py-1 text-sm"
                  >
                    <option value={categoryGroup}>{categoryGroup || "Select group"}</option>
                    {Object.keys(CATEGORY_GROUP).map((g) => (
                      <option key={g} value={g}>
                        {g}
                      </option>
                    ))}
                  </select>
                </div>

                {(CATEGORY_GROUP[categoryGroup] ?? []).length > 0 && (
                  <>
                    <label className="block text-sm font-medium text-gray-700 mt-2">Subcategory:</label>
                    <select
                      value={categorySub}
                      onChange={(e) => setCategorySub(e.target.value)}
                      className="border rounded px-2 py-1 text-sm"
                    >
                      {(CATEGORY_GROUP[categoryGroup] || []).map((sub) => (
                        <option key={sub} value={sub}>
                          {sub}
                        </option>
                      ))}
                    </select>
                  </>
                )}
              </div>
            </div>

            {/* Description */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Description</label>
              <textarea
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                className="w-full h-28 border rounded-lg px-3 py-2"
                placeholder="Description"
                required
                disabled={saving}
              />
            </div>

            {/* Content / Assign */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Content Type</label>
                <div className="px-3 py-2 border rounded-lg bg-gray-100 text-gray-700">
                  {contentType === "video" ? "Video" : "Document"}
                </div>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Assign Type</label>
                <select
                  value={assignType}
                  onChange={(e) => setAssignType(e.target.value as any)}
                  className="w-full border rounded-lg px-3 py-2"
                  disabled={saving}
                >
                  {TARGET_OPTION["Option"].map((option) => (
                    <option key={option.index} value={option.index}>
                      {option.option}
                    </option>
                  ))}
                </select>
              </div>
            </div>

            {/* Video upload */}
            {contentType === "video" && (
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Upload Video</label>
                <input
                  type="file"
                  accept="video/*"
                  onChange={(e) => {
                    const file = e.target.files?.[0] || null;
                    setVideoFile(file);
                  }}
                  disabled={saving}
                  className="w-full border rounded-lg px-3 py-2"
                />
              </div>
            )}

            {/* Quiz toggle */}
            <div className="flex items-center gap-3">
              <label className="flex items-center gap-2">
                <input
                  type="checkbox"
                  checked={quizAvailable}
                  onChange={(e) => setQuizAvailable(e.target.checked)}
                  disabled={saving}
                />
                <span className="text-sm">Quiz available</span>
              </label>
            </div>

            {/* Quiz editor */}
            {quizAvailable && (
              <div className="border rounded-lg p-4 bg-gray-50">
                <div className="flex items-center justify-between mb-3">
                  <h3 className="text-sm font-semibold">Questions</h3>
                  <button
                    type="button"
                    onClick={addQuestion}
                    className="inline-flex items-center gap-2 px-3 py-1 bg-white border rounded text-sm"
                    disabled={saving}
                  >
                    <Plus size={14} /> Add question
                  </button>
                </div>

                <div className="space-y-4">
                  {questions.map((q, qi) => (
                    <div key={q.questionId ?? `new-${qi}`} className="bg-white border rounded p-3">
                      {/* Header row */}
                      <div className="flex justify-between items-start gap-3">
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-1">
                            <label className="text-xs text-gray-500">Question {qi + 1}</label>
                            <select
                              value={q.type}
                              onChange={(e) => updateQuestionType(qi, e.target.value as QuestionTypeUI)}
                              className="text-xs border rounded px-1.5 py-0.5"
                              disabled={saving}
                            >
                              <option value="MULTIPLE">Multiple choice</option>
                              <option value="FILL_BLANK">Fill in the blank</option>
                            </select>
                            <input
                              type="number"
                              min={1}
                              value={q.points ?? 1}
                              onChange={(e) => updateQuestionPoints(qi, Number(e.target.value) || 1)}
                              className="w-14 text-xs border rounded px-1 py-0.5"
                              title="Points"
                              disabled={saving}
                            />
                          </div>
                          <input
                            value={q.questionText}
                            onChange={(e) => updateQuestionText(qi, e.target.value)}
                            className="w-full mt-1 border rounded px-2 py-1 text-sm"
                            placeholder="Question text"
                            disabled={saving}
                          />
                        </div>

                        <div className="flex flex-col items-end gap-2">
                          <button
                            type="button"
                            onClick={() => removeQuestion(qi)}
                            className="text-red-500"
                            disabled={saving}
                          >
                            <Trash2 size={16} />
                          </button>
                        </div>
                      </div>

                      {/* MULTIPLE */}
                      {q.type === "MULTIPLE" && (
                        <div className="mt-3 space-y-2">
                          {q.choices.map((c, ci) => (
                            <div key={c.choiceId ?? `q${qi}-c${ci}`} className="flex items-center gap-2">
                              <button
                                type="button"
                                onClick={() => toggleChoiceCorrect(qi, ci)}
                                className={`px-2 py-1 rounded text-xs ${
                                  c.correct ? "bg-green-500 text-white" : "bg-gray-200 text-gray-700"
                                }`}
                                disabled={saving}
                              >
                                {c.correct ? "✓" : "○"}
                              </button>
                              <input
                                value={c.text}
                                onChange={(e) => updateChoiceText(qi, ci, e.target.value)}
                                className="flex-1 border rounded px-2 py-1 text-sm"
                                placeholder={`Choice ${ci + 1}`}
                                disabled={saving}
                              />
                              {q.choices.length > 2 && (
                                <button
                                  type="button"
                                  onClick={() => removeChoice(qi, ci)}
                                  className="text-red-500"
                                  disabled={saving}
                                >
                                  <Trash2 size={16} />
                                </button>
                              )}
                            </div>
                          ))}

                          <div>
                            <button
                              type="button"
                              onClick={() => addChoice(qi)}
                              className="mt-2 inline-flex items-center gap-2 px-2 py-1 bg-white border rounded text-xs"
                              disabled={saving}
                            >
                              <Plus size={12} /> Add choice
                            </button>
                          </div>
                        </div>
                      )}

                      {/* FILL IN THE BLANK */}
                      {q.type === "FILL_BLANK" && (
                        <div className="mt-3">
                          <label className="text-xs text-gray-500">Correct answer</label>
                          <input
                            value={q.correctAnswer ?? ""}
                            onChange={(e) => updateFillBlankAnswer(qi, e.target.value)}
                            className="w-full border rounded px-2 py-1 text-sm mt-1"
                            placeholder="Type the correct answer"
                            disabled={saving}
                          />
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Actions */}
            <div className="flex justify-end gap-3 pt-2">
              <button type="button" onClick={onClose} className="px-4 py-2 rounded-lg border" disabled={saving}>
                Cancel
              </button>
              <button
                type="submit"
                className="px-4 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 flex items-center gap-2 disabled:opacity-60"
                disabled={saving}
              >
                <Save size={16} /> {saving ? "Saving..." : "Save"}
              </button>
            </div>
          </form>
        )}
      </div>
    </div>
  );

  return createPortal(modal, document.body);
};

export default EditLessonModal;

2025-11-14 10:40:54,528 INFO  [Tes.LearningContentResource] (executor-thread-10) Question DTOs in method -> getOne : {"id":"65cbcaacc7ae414594cf1","title":"test","description":"test","category":"Technical Skills > Programming & Development","thumbnailUrl":"","authorName":"Nattida Kraisikaj","contentType":"video","authorEmail":"user2@gmail.com","videoUrl":"uploads/video/65cbcaacc7ae414594cf1.mp4","documentUrl":null,"authorAvatarUrl":"uploads/avatars/avatar_UeJ5XJf6np3VVCJcRx_FI.jpg","progressPercent":0,"clickCount":2,"assignType":"all","assignedUserIds":[],"assignedTeamIds":[],"dueDate":null,"quizAvailable":true,"questions":[{"questionId":null,"questionText":"t1","type":"MULTIPLE","points":1,"choices":[],"correctAnswer":null},{"questionId":null,"questionText":"t2","type":"MULTIPLE","points":1,"choices":[],"correctAnswer":null},{"questionId":null,"questionText":"t3","type":"MULTIPLE","points":1,"choices":[],"correctAnswer":null},{"questionId":null,"questionText":"t1","type":"MULTIPLE","points":1,"choices":[{"choiceId":"0afda7069426472787dc6","text":"t3","selected":false,"correct":false},{"choiceId":"30f97c9df3b5452880941","text":"t2","selected":false,"correct":false},{"choiceId":"80e6c5ce42d1480991452","text":"t1","selected":false,"correct":true}],"correctAnswer":null},{"questionId":null,"questionText":"t2","type":"MULTIPLE","points":1,"choices":[{"choiceId":"274371faa09b4b68a5cc4","text":"t3","selected":false,"correct":false},{"choiceId":"779d855c321f4689b0c38","text":"t2","selected":false,"correct":true},{"choiceId":"f8b4ce5b37d44f758c5db","text":"t1","selected":false,"correct":false}],"correctAnswer":null},{"questionId":null,"questionText":"t3","type":"MULTIPLE","points":1,"choices":[{"choiceId":"3bac120f6b6842bc9ea98","text":"t1","selected":false,"correct":false},{"choiceId":"84bd3f76782146528350c","text":"t3","selected":false,"correct":true},{"choiceId":"94eb2fc456bb4427b7ab6","text":"t2","selected":false,"correct":false}],"correctAnswer":null}],"maxAttempts":3}       
