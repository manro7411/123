@PUT
@Path("/{id}")
@Transactional
@RolesAllowed(Roles.ROLE_TRAINER)
public LearningContentDto update(
        @PathParam("id") String id,
        LearningContentDto dto,
        @Context SecurityContext securityContext
) {
    String currentUser = securityContext.getUserPrincipal().getName();
    String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();
    log.info("User '{}' called method '{}' to update Learning content with ID: {}", currentUser, methodName, id);

    LearningContent lc = em.find(LearningContent.class, id);
    if (lc == null) {
        log.error("Learning content with ID: {} not found in method -> {}", id, methodName);
        throw new NotFoundException();
    }

    // ถ้าต้องการบังคับเฉพาะเจ้าของ
    if (lc.getAuthorEmail() != null &&
            !lc.getAuthorEmail().equalsIgnoreCase(currentUser)) {
        log.warn("User '{}' is not owner of content {} in method {}", currentUser, id, methodName);
        throw new ForbiddenException("You are not the owner of this content");
    }

    // ---------------- Basic fields ----------------
    if (dto.title() != null) {
        lc.setTitle(dto.title());
        log.info("Updating title to: {} in Method {}", dto.title(), methodName);
    }
    if (dto.description() != null) {
        lc.setDescription(dto.description());
        log.info("Updating description to: {} in Method {}", dto.description(), methodName);
    }
    if (dto.category() != null) {
        lc.setCategory(dto.category());
        log.info("Updating category to: {} in Method {}", dto.category(), methodName);
    }
    if (dto.thumbnailUrl() != null) {
        lc.setThumbnailUrl(dto.thumbnailUrl());
        log.info("Updating thumbnailUrl to: {} in Method {}", dto.thumbnailUrl(), methodName);
    }
    if (dto.authorAvatarUrl() != null) {
        lc.setAuthorAvatarUrl(dto.authorAvatarUrl());
        log.info("Updating authorAvatarUrl to: {} in Method {}", dto.authorAvatarUrl(), methodName);
    }
    if (dto.assignType() != null) {
        lc.setAssignType(dto.assignType());
        log.info("Updating assignType to: {} in Method {}", dto.assignType(), methodName);
    }

    if (dto.assignedUserIds() != null) {
        var merged = new LinkedHashSet<>(
                Optional.ofNullable(lc.getAssignedUserIds()).orElseGet(ArrayList::new)
        );
        merged.addAll(dto.assignedUserIds());
        lc.setAssignedUserIds(new ArrayList<>(merged));
    }

    if (dto.assignedTeamIds() != null) {
        var merged = new LinkedHashSet<>(
                Optional.ofNullable(lc.getAssignedTeamIds()).orElseGet(ArrayList::new)
        );
        merged.addAll(dto.assignedTeamIds());
        lc.setAssignedTeamIds(new ArrayList<>(merged));
    }

    if (dto.dueDate() != null) {
        lc.setDueDate(dto.dueDate());
        log.info("Setting due date to: {} in Method {}", dto.dueDate(), methodName);
    }

    // ---------------- Quiz update logic ----------------
    List<QuestionDTO> resultQuestionDtos = new ArrayList<>();

    if (dto.questions() != null) {
        // ดึง questions เดิมของ content นี้
        List<QuestionEntity> existingQuestions = Optional.ofNullable(lc.getQuestions())
                .orElseGet(ArrayList::new);

        Map<String, QuestionEntity> existingById = existingQuestions.stream()
                .filter(q -> q.getId() != null)
                .collect(Collectors.toMap(QuestionEntity::getId, q -> q));

        // จะเก็บ id ของคำถามที่ยังต้องอยู่หลังอัปเดต
        Set<String> keepQuestionIds = new HashSet<>();

        for (QuestionDTO qdto : dto.questions()) {
            // ปรับให้ตรง DTO จริง ถ้าใช้ field -> qdto.getId()
            String incomingId = qdto.id();

            QuestionEntity question;

            if (incomingId != null && existingById.containsKey(incomingId)) {
                // ✅ แก้คำถามเดิม → ใช้ question เดิม id เดิม
                question = existingById.get(incomingId);
                log.info("Updating existing question ID: {} in Method {}", question.getId(), methodName);
            } else {
                // ✅ คำถามใหม่ → gen id ใหม่
                question = new QuestionEntity();
                String newId = UUID.randomUUID().toString().replace("-", "").substring(0, 21);
                question.setId(newId);
                question.setLearningContent(lc);
                em.persist(question);

                // ผูกกับ lc
                if (lc.getQuestions() == null) {
                    lc.setQuestions(new ArrayList<>());
                }
                lc.getQuestions().add(question);

                log.info("Creating new question ID: {} in Method {}", newId, methodName);
            }

            keepQuestionIds.add(question.getId());

            // อัปเดต field ของ question
            question.setQuestionText(qdto.questionText());
            question.setPoints(
                    qdto.points() != null ? qdto.points() : 1
            );

            QuestionType type = QuestionType.valueOf(
                    qdto.type() != null ? qdto.type().toUpperCase() : QuestionType.TEXT.name()
            );
            question.setType(type);

            // ---------- Choices (สำหรับ Multiple choice) ----------
            if (qdto.choices() != null &&
                    (type == QuestionType.MULTIPLE || type == QuestionType.MULTIPLE_CHOICE)) {

                List<QuestionChoiceEntity> existingChoices =
                        Optional.ofNullable(question.getChoices()).orElseGet(ArrayList::new);

                Map<String, QuestionChoiceEntity> existingChoiceById = existingChoices.stream()
                        .filter(c -> c.getId() != null)
                        .collect(Collectors.toMap(QuestionChoiceEntity::getId, c -> c));

                Set<String> keepChoiceIds = new HashSet<>();

                for (ChoiceDTO cdto : qdto.choices()) {
                    // ปรับให้ตรงของจริง เช่น getId()/getChoiceId()
                    String incomingChoiceId = cdto.getChoiceId();

                    QuestionChoiceEntity choice;
                    if (incomingChoiceId != null && existingChoiceById.containsKey(incomingChoiceId)) {
                        // ✅ แก้ choice เดิม → ใช้ id เดิม
                        choice = existingChoiceById.get(incomingChoiceId);
                        log.info("Updating existing choice ID: {} for question ID: {}",
                                choice.getId(), question.getId());
                    } else {
                        // ✅ choice ใหม่ → gen id ใหม่
                        choice = new QuestionChoiceEntity();
                        String newCid = incomingChoiceId != null
                                ? incomingChoiceId
                                : UUID.randomUUID().toString().replace("-", "").substring(0, 21);
                        choice.setId(newCid);
                        choice.setQuestion(question);
                        em.persist(choice);
                        existingChoices.add(choice);
                        log.info("Creating new choice ID: {} for question ID: {}", newCid, question.getId());
                    }

                    keepChoiceIds.add(choice.getId());
                    choice.setChoiceText(cdto.getText());
                    choice.setCorrect(cdto.isCorrect());
                }

                // ลบ choice ที่ไม่ถูกส่งมาแล้ว
                for (Iterator<QuestionChoiceEntity> it = existingChoices.iterator(); it.hasNext(); ) {
                    QuestionChoiceEntity c = it.next();
                    if (!keepChoiceIds.contains(c.getId())) {
                        log.info("Removing choice ID: {} from question ID: {}", c.getId(), question.getId());
                        em.remove(c);
                        it.remove();
                    }
                }

                question.setChoices(existingChoices);

            } else {
                // ไม่ใช่ multiple choice → ลบ choices เดิมออก
                if (question.getChoices() != null && !question.getChoices().isEmpty()) {
                    for (QuestionChoiceEntity c : new ArrayList<>(question.getChoices())) {
                        em.remove(c);
                    }
                    question.getChoices().clear();
                }
            }

            resultQuestionDtos.add(qdto);
        }

        // ลบคำถามที่ไม่มีใน DTO แล้ว
        for (Iterator<QuestionEntity> it = lc.getQuestions().iterator(); it.hasNext(); ) {
            QuestionEntity q = it.next();
            if (!keepQuestionIds.contains(q.getId())) {
                log.info("Removing question ID: {} from content {}", q.getId(), id);
                // ลบ choices ด้วย
                if (q.getChoices() != null) {
                    for (QuestionChoiceEntity c : new ArrayList<>(q.getChoices())) {
                        em.remove(c);
                    }
                }
                em.remove(q);
                it.remove();
            }
        }

    } else {
        log.info("No questions in DTO, keeping existing quiz for content ID: {}", id);
    }

    em.flush();
    log.info("Learning content with ID: {} updated successfully in method -> {}", id, methodName);

    return LearningContentDto.withQuizInfo(lc, resultQuestionDtos);
}
ห
