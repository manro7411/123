package TrainerAnalytic.Resources;

import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;
import model.TeamEntity;
import model.User;
import org.acme.security.jwt.Roles;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Trainer Analytics endpoints (fixed to use author_email and no 'status' column)
 *
 * Base path: /trainer
 */
@Path("/trainer")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class TrainerAnalyticResources {

    private static final Logger log = LoggerFactory.getLogger(TrainerAnalyticResources.class);

    @Inject EntityManager em;

    @Inject
    TrainerUtilities trainerUtilities;


    // ===== Helpers =====
    private static LocalDate parseDateOr(String s, LocalDate fallback) {
        if (s == null || s.isBlank()) return fallback;
        return LocalDate.parse(s);
    }
    private static LocalDateTime startOfDay(LocalDate d) { return d.atStartOfDay(); }
    private static LocalDateTime dayAfter(LocalDate d) { return d.plusDays(1).atStartOfDay(); }

    /** Resolve trainer email from token principal */
    private String resolveTrainerEmail(SecurityContext sc) {
        String email = (sc.getUserPrincipal() != null) ? sc.getUserPrincipal().getName() : null;
        if (email == null || email.isBlank()) {
            throw new WebApplicationException("Missing principal", Response.Status.UNAUTHORIZED);
        }
        return email.toLowerCase();
    }

    private static LocalDate toLocalDate(Object raw) {
        if (raw == null) return null;
        if (raw instanceof LocalDate d) return d;
        if (raw instanceof java.sql.Date d) return d.toLocalDate();
        if (raw instanceof java.time.LocalDateTime dt) return dt.toLocalDate();
        if (raw instanceof java.util.Date ud)
            return ud.toInstant().atZone(java.time.ZoneId.systemDefault()).toLocalDate();
        return LocalDate.parse(raw.toString());
    }

    // =========================================================================
    // 1) OVERVIEW
    // =========================================================================
    @GET
    @Path("/overview")
    @RolesAllowed({Roles.ROLE_TRAINER, Roles.ROLE_ADMINISTRATOR})
    public Response overview(
            @Context SecurityContext securityContext,
            @QueryParam("start") String start,
            @QueryParam("end") String end,
            @QueryParam("view") @DefaultValue("individual") String view,
            @QueryParam("teamId") String teamId
    ) {
        final String trainerEmail = resolveTrainerEmail(securityContext);
        final LocalDate endDate = parseDateOr(end, LocalDate.now());
        final LocalDate startDate = parseDateOr(start, endDate.minusDays(6));
        final LocalDateTime startDT = startOfDay(startDate);
        final LocalDateTime endDT = dayAfter(endDate);

        boolean isTeamView = "team".equalsIgnoreCase(view);
        log.info("[trainer/overview] email={} view={} teamId={} window {}..(exclusive {})",
                trainerEmail, view, teamId, startDT, endDT);

        String contentFilter = isTeamView ? "lc.team_id = :teamId" : "lc.author_email = :email";

        // KPI: total contents
        String totalContentSql = "SELECT COUNT(*) FROM learning_content lc WHERE " + contentFilter;
        Query totalContentQuery = em.createNativeQuery(totalContentSql);
        if (isTeamView) totalContentQuery.setParameter("teamId", teamId);
        else totalContentQuery.setParameter("email", trainerEmail);
        long totalContents = ((Number) totalContentQuery.getSingleResult()).longValue();

        // KPI: active learners
        String activeLearnersSql = String.format("""
        SELECT COUNT(DISTINCT p.user_email)
        FROM user_lesson_progress p
        JOIN learning_content lc ON p.lesson_id = lc.id
        WHERE %s
          AND (
              (p.started_at IS NOT NULL AND p.started_at >= :start AND p.started_at < :end)
           OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
          )
    """, contentFilter);
        Query activeLearnersQuery = em.createNativeQuery(activeLearnersSql)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (isTeamView) activeLearnersQuery.setParameter("teamId", teamId);
        else activeLearnersQuery.setParameter("email", trainerEmail);
        long activeLearners = ((Number) activeLearnersQuery.getSingleResult()).longValue();

        // KPI: new enrollments
        String newEnrollmentsSql = String.format("""
        SELECT COUNT(*)
        FROM user_lesson_progress p
        JOIN learning_content lc ON p.lesson_id = lc.id
        WHERE %s
          AND p.started_at IS NOT NULL
          AND p.started_at >= :start AND p.started_at < :end
    """, contentFilter);
        Query newEnrollmentsQuery = em.createNativeQuery(newEnrollmentsSql)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (isTeamView) newEnrollmentsQuery.setParameter("teamId", teamId);
        else newEnrollmentsQuery.setParameter("email", trainerEmail);
        long newEnrollments = ((Number) newEnrollmentsQuery.getSingleResult()).longValue();

        // KPI: completion rate & avg score
        String rateSql = String.format("""
        SELECT
          AVG(CASE WHEN p.percent = 100 THEN 1.0 ELSE 0.0 END),
          AVG(p.score)
        FROM user_lesson_progress p
        JOIN learning_content lc ON p.lesson_id = lc.id
        WHERE %s
          AND (
              (p.started_at IS NOT NULL AND p.started_at >= :start AND p.started_at < :end)
           OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
          )
    """, contentFilter);
        Query rateQuery = em.createNativeQuery(rateSql)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (isTeamView) rateQuery.setParameter("teamId", teamId);
        else rateQuery.setParameter("email", trainerEmail);
        Object[] rateRow = (Object[]) rateQuery.getSingleResult();
        double completionRate = rateRow[0] == null ? 0d : ((Number) rateRow[0]).doubleValue();
        Double avgScore = rateRow[1] == null ? null : ((Number) rateRow[1]).doubleValue();

        // Trend: enroll detail per day
        String enrollDetailSql = String.format("""
        SELECT DATE(p.started_at), u.name, p.user_email, lc.title , p.started_at
        FROM user_lesson_progress p
        JOIN users u ON u.email = p.user_email
        JOIN learning_content lc ON p.lesson_id = lc.id
        WHERE %s
          AND p.started_at IS NOT NULL
          AND p.started_at >= :start AND p.started_at < :end
    """, contentFilter);
        Query enrollDetailQuery = em.createNativeQuery(enrollDetailSql)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (isTeamView) enrollDetailQuery.setParameter("teamId", teamId);
        else enrollDetailQuery.setParameter("email", trainerEmail);
        List<Object[]> enrollDetails = enrollDetailQuery.getResultList();

        // Trend: complete detail per day
        String completeDetailSql = String.format("""
            SELECT DATE(p.completed_at), u.name, p.user_email, lc.title, p.score , p.total_questions , p.completed_at
            FROM user_lesson_progress p
            JOIN users u ON u.email = p.user_email
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND p.completed_at IS NOT NULL
              AND p.completed_at >= :start AND p.completed_at < :end
        """, contentFilter);
        Query completeDetailQuery = em.createNativeQuery(completeDetailSql)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (isTeamView) completeDetailQuery.setParameter("teamId", teamId);
        else completeDetailQuery.setParameter("email", trainerEmail);
        List<Object[]> completeDetails = completeDetailQuery.getResultList();

        // Merge trend with user details
        Map<LocalDate, Map<String, List<Map<String, Object>>>> trendMap = new LinkedHashMap<>();
        for (LocalDate d = startDate; !d.isAfter(endDate); d = d.plusDays(1)) {
            Map<String, List<Map<String, Object>>> daily = new HashMap<>();
            daily.put("enroll", new ArrayList<>());
            daily.put("complete", new ArrayList<>());
            trendMap.put(d, daily);
        }

        for (Object[] r : enrollDetails) {
            LocalDate d = ((java.sql.Date) r[0]).toLocalDate();
            if (trendMap.containsKey(d)) {
                Map<String, Object> user = Map.of(
                        "name", r[1],
                        "email", r[2],
                        "course", r[3],
                        "startedAt", r[4]
                );
                trendMap.get(d).get("enroll").add(user);
            }
        }

        for (Object[] r : completeDetails) {
            LocalDate d = ((java.sql.Date) r[0]).toLocalDate();
            if (trendMap.containsKey(d)) {
                Map<String, Object> user = Map.of(
                        "name", r[1],
                        "email", r[2],
                        "course", r[3],
                        "score", r[4],
                        "totalQuestions", r[5],
                        "CompletedAt", r[6]
                );
                trendMap.get(d).get("complete").add(user);
            }
        }

        List<Map<String, Object>> trend = new ArrayList<>();
        trendMap.forEach((date, data) -> {
            Map<String, Object> row = new LinkedHashMap<>();
            row.put("date", date.toString());
            row.put("enrollCount", data.get("enroll").size());
            row.put("completeCount", data.get("complete").size());
            row.put("enroll", data.get("enroll"));
            row.put("complete", data.get("complete"));
            trend.add(row);
        });

        // Final response
        Map<String, Object> kpi = new LinkedHashMap<>();
        kpi.put("totalContents", totalContents);
        kpi.put("newEnrollments", newEnrollments);
        kpi.put("completionRate", completionRate);
        kpi.put("avgScore", avgScore);

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("kpi", kpi);
        out.put("trend", trend);

        return Response.ok(out).build();
    }

    // =========================================================================
    // 2) CONTENT PERFORMANCE (table)
    // =========================================================================
    @GET
    @Path("/content-performance")
    @RolesAllowed({Roles.ROLE_TRAINER, Roles.ROLE_ADMINISTRATOR})
    public Response contentPerformance(
            @Context SecurityContext securityContext,
            @QueryParam("start") String start,
            @QueryParam("end") String end,
            @QueryParam("order") @DefaultValue("completionRate:desc") String order,
            @QueryParam("limit") @DefaultValue("20") int limit,
            @QueryParam("offset") @DefaultValue("0") int offset
    ) {
        final String trainerEmail = resolveTrainerEmail(securityContext);
        final LocalDate endDate = parseDateOr(end, LocalDate.now());
        final LocalDate startDate = parseDateOr(start, endDate.minusDays(6));
        final LocalDateTime startDT = startOfDay(startDate);
        final LocalDateTime endDT = dayAfter(endDate);

        if (limit < 1) limit = 20;
        if (limit > 200) limit = 200;
        if (offset < 0) offset = 0;

        String orderSql = "completion_rate DESC";
        if (order != null && !order.isBlank()) {
            String[] parts = order.split(":");
            String field = parts[0];
            String dir = parts.length > 1 ? parts[1] : "asc";
            String sortDir = "desc".equalsIgnoreCase(dir) ? "DESC" : "ASC";
            switch (field) {
                case "title" -> orderSql = "lc.title " + sortDir;
                case "learners" -> orderSql = "learners " + sortDir;
                case "avgScore" -> orderSql = "avg_score " + sortDir;
                case "completionRate" -> orderSql = "completion_rate " + sortDir;
            }
        }

        // Main content performance query
        String sql = """
        SELECT
          lc.id AS content_id,
          lc.title AS title,
          COUNT(DISTINCT p.user_email) AS learners,
          AVG(CASE WHEN p.percent = 100 THEN 1.0 ELSE 0.0 END) AS completion_rate,
          AVG(p.score) AS avg_score
        FROM learning_content lc
        LEFT JOIN user_lesson_progress p ON p.lesson_id = lc.id
          AND (
               (p.started_at IS NOT NULL AND p.started_at >= :start AND p.started_at < :end)
            OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
          )
        WHERE lc.author_email = :email
        GROUP BY lc.id, lc.title
        ORDER BY %s
    """.formatted(orderSql);

        Query q = em.createNativeQuery(sql)
                .setParameter("email", trainerEmail)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        q.setFirstResult(offset);
        q.setMaxResults(limit);

        @SuppressWarnings("unchecked")
        List<Object[]> rows = q.getResultList();

        // Collect content IDs for learner query
        List<String> contentIds = rows.stream()
                .map(r -> String.valueOf(r[0]))
                .collect(Collectors.toList());

        // Learner details query
        String learnerSql = """
        SELECT
          p.lesson_id AS content_id,
          u.name AS learner_name,
          p.user_email,
          p.percent,
          p.score
        FROM user_lesson_progress p
        JOIN users u ON u.email = p.user_email
        WHERE p.lesson_id IN :contentIds
          AND (
               (p.started_at IS NOT NULL AND p.started_at >= :start AND p.started_at < :end)
            OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
          )
    """;

        Query learnerQuery = em.createNativeQuery(learnerSql)
                .setParameter("contentIds", contentIds)
                .setParameter("start", startDT)
                .setParameter("end", endDT);

        @SuppressWarnings("unchecked")
        List<Object[]> learnerRows = learnerQuery.getResultList();

        // Map learners by content ID
        Map<String, List<Map<String, Object>>> learnersByContent = new HashMap<>();
        for (Object[] r : learnerRows) {
            String contentId = String.valueOf(r[0]);
            Map<String, Object> learner = new LinkedHashMap<>();
            learner.put("name", r[1]);
            learner.put("email", r[2]);
            learner.put("percent", r[3]);
            learner.put("score", r[4]);
            learnersByContent.computeIfAbsent(contentId, k -> new ArrayList<>()).add(learner);
        }

        // Build final response
        List<Map<String, Object>> items = new ArrayList<>(rows.size());
        for (Object[] r : rows) {
            String contentId = String.valueOf(r[0]);
            Map<String, Object> m = new LinkedHashMap<>();
            m.put("contentId", contentId);
            m.put("title", r[1]);
            m.put("learnersCount", ((Number) (r[2] == null ? 0 : r[2])).longValue());
            m.put("completionRate", r[3] == null ? 0d : ((Number) r[3]).doubleValue());
            m.put("avgScore", r[4] == null ? null : ((Number) r[4]).doubleValue());
            m.put("learners", learnersByContent.getOrDefault(contentId, List.of()));
            items.add(m);
        }

        Number total = (Number) em.createNativeQuery("""
        SELECT COUNT(*) FROM learning_content lc WHERE lc.author_email = :email
    """).setParameter("email", trainerEmail).getSingleResult();

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("items", items);
        out.put("total", total.longValue());
        out.put("limit", limit);
        out.put("offset", offset);
        return Response.ok(out).build();
    }

    // =========================================================================
    // 3) CONTENT FUNNEL
    // =========================================================================
    @GET
    @Path("/content-funnel")
    @RolesAllowed({Roles.ROLE_TRAINER,Roles.ROLE_ADMINISTRATOR})
    public Response contentFunnel(
            @Context SecurityContext securityContext,
            @QueryParam("contentId") String contentId,
            @QueryParam("start") String start,
            @QueryParam("end")   String end
    ) {
        if (contentId == null || contentId.isBlank()) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(Map.of("error", "Missing contentId")).build();
        }
        final String trainerEmail = resolveTrainerEmail(securityContext);
        final LocalDate endDate   = parseDateOr(end, LocalDate.now());
        final LocalDate startDate = parseDateOr(start, endDate.minusDays(6));
        final LocalDateTime startDT = startOfDay(startDate);
        final LocalDateTime endDT   = dayAfter(endDate);

        // confirm ownership by email
        Number owned = (Number) em.createNativeQuery("""
            SELECT COUNT(*) FROM learning_content lc WHERE lc.id = :cid AND lc.author_email = :email
        """).setParameter("cid", contentId)
                .setParameter("email", trainerEmail)
                .getSingleResult();
        if (owned.intValue() == 0) {
            return Response.status(Response.Status.FORBIDDEN)
                    .entity(Map.of("error","Content not owned by trainer")).build();
        }

        Number enrolled = (Number) em.createNativeQuery("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            WHERE p.lesson_id = :cid
              AND p.started_at IS NOT NULL
              AND p.started_at >= :start AND p.started_at < :end
        """).setParameter("cid", contentId)
                .setParameter("start", startDT)
                .setParameter("end", endDT)
                .getSingleResult();

        Number half = (Number) em.createNativeQuery("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            WHERE p.lesson_id = :cid
              AND p.percent >= 50
              AND (
                   (p.started_at  IS NOT NULL AND p.started_at  >= :start AND p.started_at  < :end)
                OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
              )
        """).setParameter("cid", contentId)
                .setParameter("start", startDT)
                .setParameter("end", endDT)
                .getSingleResult();

        Number completed = (Number) em.createNativeQuery("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            WHERE p.lesson_id = :cid
              AND p.completed_at IS NOT NULL
              AND p.completed_at >= :start AND p.completed_at < :end
        """).setParameter("cid", contentId)
                .setParameter("start", startDT)
                .setParameter("end", endDT)
                .getSingleResult();

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("contentId", contentId);
        out.put("funnel", Map.of(
                "enrolled",  enrolled.longValue(),
                "started",   enrolled.longValue(),
                "half",      half.longValue(),
                "completed", completed.longValue()
        ));
        return Response.ok(out).build();
    }

    @GET
    @Path("/assignable-teams")
    @RolesAllowed({Roles.ROLE_TRAINER})
    public Response getAssignableTeams(@Context SecurityContext sc) {
        String trainerEmail = sc.getUserPrincipal().getName();
        log.info("Incoming Info: get assignable teams for trainer {}", trainerEmail);
        User trainer = em.createQuery("SELECT u FROM User u WHERE u.email = :email", User.class)
                .setParameter("email", trainerEmail)
                .getSingleResult();

        List<TeamEntity> teams = trainerUtilities.getTeamsAssignedToTrainer(trainer.getEmail());

        List<Map<String, String>> result = teams.stream()
                .map(team -> Map.of(
                        "id", team.getId(),
                        "name", team.getName(),
                        "description", team.getDescription()
                ))
                .collect(Collectors.toList());

        return Response.ok(result).build();
    }
}
