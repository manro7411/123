package QuizService.DTOs;

import java.util.List;

public class QuestionDTO {
    public String id;              // ✅ ใช้สำหรับระบุข้อเดิม (optional)
    public String questionText;
    public String type;
    public Integer points = 1;
    public List<ChoiceDTO> choices;
    public String correctAnswer;   // สำหรับ FILL_BLANK / SHORT_ANSWER ฯลฯ

    public QuestionDTO() {
    }

    public QuestionDTO(String id, String questionText, String type, Integer points,
                       List<ChoiceDTO> choices, String correctAnswer) {
        this.id = id;
        this.questionText = questionText;
        this.type = type;
        this.points = points;
        this.choices = choices;
        this.correctAnswer = correctAnswer;
    }

    public QuestionDTO(String questionText, String type, int points, List<ChoiceDTO> choices) {
        this.questionText = questionText;
        this.type = type;
        this.points = points;
        this.choices = choices;
    }

    public QuestionDTO(String questionText, String type, int points, String correctAnswer) {
        this.questionText = questionText;
        this.type = type;
        this.points = points;
        this.correctAnswer = correctAnswer;
    }
}

@PUT
@Path("/{id}")
@Transactional
@RolesAllowed(Roles.ROLE_TRAINER)
public LearningContentDto update(
        @PathParam("id") String id,
        LearningContentDto dto,
        @Context SecurityContext securityContext
) {
    String currentUser = securityContext.getUserPrincipal().getName();
    String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();
    log.info("User '{}' called method '{}' to update Learning content with ID: {}", currentUser, methodName, id);

    LearningContent lc = em.find(LearningContent.class, id);
    if (lc == null) {
        log.error("Learning content with ID: {} not found in method -> {}", id, methodName);
        throw new NotFoundException();
    }

    // ===== basic fields (เหมือนเดิม) =====
    if (dto.title() != null) lc.setTitle(dto.title());
    if (dto.description() != null) lc.setDescription(dto.description());
    if (dto.category() != null) lc.setCategory(dto.category());
    if (dto.thumbnailUrl() != null) lc.setThumbnailUrl(dto.thumbnailUrl());
    if (dto.authorAvatarUrl() != null) lc.setAuthorAvatarUrl(dto.authorAvatarUrl());
    if (dto.assignType() != null) lc.setAssignType(dto.assignType());

    if (dto.assignedUserIds() != null) {
        var merged = new LinkedHashSet<>(
                Optional.ofNullable(lc.getAssignedUserIds()).orElseGet(ArrayList::new)
        );
        merged.addAll(dto.assignedUserIds());
        lc.setAssignedUserIds(new ArrayList<>(merged));
    }

    if (dto.assignedTeamIds() != null) {
        var merged = new LinkedHashSet<>(
                Optional.ofNullable(lc.getAssignedTeamIds()).orElseGet(ArrayList::new)
        );
        merged.addAll(dto.assignedTeamIds());
        lc.setAssignedTeamIds(new ArrayList<>(merged));
    }

    if (dto.dueDate() != null) {
        lc.setDueDate(dto.dueDate());
    }

    // ===== QUIZ UPDATE (เวอร์ชันใหม่ตาม requirement) =====
    List<QuestionDTO> returnedQuestionDtos = new ArrayList<>();

    if (dto.questions() != null) {
        // ดึงคำถามเดิมทั้งหมดของ content นี้
        List<QuestionEntity> existingQuestions =
                Optional.ofNullable(lc.getQuestions()).orElseGet(ArrayList::new);

        Map<String, QuestionEntity> existingById = existingQuestions.stream()
                .filter(q -> q.getId() != null)
                .collect(Collectors.toMap(QuestionEntity::getId, q -> q));

        // questionIds ที่จะเก็บไว้หลังจากอัปเดต (ไว้ลบของที่ไม่อยู่ใน DTO)
        Set<String> keepQuestionIds = new HashSet<>();

        for (QuestionDTO qdto : dto.questions()) {
            // อ่านจาก public fields ของ QuestionDTO
            String qId = qdto.id;
            QuestionEntity q;

            if (qId != null && existingById.containsKey(qId)) {
                // ✅ แก้ไขคำถามเดิม
                q = existingById.get(qId);
                log.info("Updating existing question ID: {}", qId);
            } else {
                // ✅ เพิ่มคำถามใหม่ → gen id ใหม่
                q = new QuestionEntity();
                String newId = UUID.randomUUID().toString().replace("-", "").substring(0, 21);
                q.setId(newId);
                q.setLearningContent(lc);

                if (lc.getQuestions() == null) {
                    lc.setQuestions(new ArrayList<>());
                }
                lc.getQuestions().add(q);
                em.persist(q);

                log.info("Creating new question ID: {}", newId);
            }

            keepQuestionIds.add(q.getId());

            // อัปเดตข้อมูลคำถาม
            q.setQuestionText(qdto.questionText);
            q.setPoints(qdto.points != null ? qdto.points : 1);

            QuestionType type = QuestionType.valueOf(
                    (qdto.type != null ? qdto.type : QuestionType.TEXT.name()).toUpperCase()
            );
            q.setType(type);

            // ----- Multiple choice -----
            if (type == QuestionType.MULTIPLE || type == QuestionType.MULTIPLE_CHOICE) {
                // จัดการ choices
                List<QuestionChoiceEntity> existingChoices =
                        Optional.ofNullable(q.getChoices()).orElseGet(ArrayList::new);

                Map<String, QuestionChoiceEntity> choiceById = existingChoices.stream()
                        .filter(c -> c.getId() != null)
                        .collect(Collectors.toMap(QuestionChoiceEntity::getId, c -> c));

                Set<String> keepChoiceIds = new HashSet<>();

                if (qdto.choices != null) {
                    for (ChoiceDTO cdto : qdto.choices) {
                        String cId = cdto.getChoiceId();
                        QuestionChoiceEntity choice;

                        if (cId != null && choiceById.containsKey(cId)) {
                            // ✅ update choice เดิม
                            choice = choiceById.get(cId);
                            log.info("Updating choice ID: {} for question ID: {}", cId, q.getId());
                        } else {
                            // ✅ choice ใหม่
                            choice = new QuestionChoiceEntity();
                            String newCid = (cId != null)
                                    ? cId
                                    : UUID.randomUUID().toString().replace("-", "").substring(0, 21);
                            choice.setId(newCid);
                            choice.setQuestion(q);
                            em.persist(choice);
                            existingChoices.add(choice);
                            log.info("Creating new choice ID: {} for question ID: {}", newCid, q.getId());
                        }

                        keepChoiceIds.add(choice.getId());
                        choice.setChoiceText(cdto.getText());
                        choice.setCorrect(cdto.isCorrect());
                    }
                }

                // ลบ choice ที่ไม่อยู่ใน DTO แล้ว
                for (Iterator<QuestionChoiceEntity> it = existingChoices.iterator(); it.hasNext(); ) {
                    QuestionChoiceEntity c = it.next();
                    if (!keepChoiceIds.contains(c.getId())) {
                        log.info("Removing choice ID: {} from question ID: {}", c.getId(), q.getId());
                        em.remove(c);
                        it.remove();
                    }
                }

                q.setChoices(existingChoices);
            }
            // ----- Fill in the blank / short answer -----
            else if (type == QuestionType.FILL_BLANK || type == QuestionType.SHORT_ANSWER) {
                // ตรงนี้ขึ้นกับโครงสร้างจริงของคุณ ว่าผูก QuestionFillBlankEntity ยังไง
                // ตัวอย่าง: เก็บ/อัปเดต correctAnswer แยกตาราง
                if (qdto.correctAnswer != null) {
                    // หา fill blank เดิม
                    QuestionFillBlankEntity fb = em.find(QuestionFillBlankEntity.class, q.getId());
                    if (fb == null) {
                        fb = new QuestionFillBlankEntity();
                        fb.setId(q.getId());     // ผูกใช้ id เดียวกับ question
                        fb.setQuestion(q);
                        em.persist(fb);
                    }
                    fb.setCorrectAnswer(qdto.correctAnswer);
                }
                // ถ้าไม่ใช่ multiple → ลบ choices เดิม (กันหลงเหลือ)
                if (q.getChoices() != null) {
                    for (QuestionChoiceEntity c : new ArrayList<>(q.getChoices())) {
                        em.remove(c);
                    }
                    q.getChoices().clear();
                }
            }
            // ----- Question type อื่น ๆ -----
            else {
                // เคลียร์ choices ถ้า type เปลี่ยนไปเป็นแบบที่ไม่ใช้ choices
                if (q.getChoices() != null) {
                    for (QuestionChoiceEntity c : new ArrayList<>(q.getChoices())) {
                        em.remove(c);
                    }
                    q.getChoices().clear();
                }
            }

            returnedQuestionDtos.add(qdto);
        }

        // ลบคำถามที่ไม่อยู่ใน DTO แล้ว
        if (lc.getQuestions() != null) {
            for (Iterator<QuestionEntity> it = lc.getQuestions().iterator(); it.hasNext(); ) {
                QuestionEntity q = it.next();
                if (!keepQuestionIds.contains(q.getId())) {
                    log.info("Removing question ID: {} from content {}", q.getId(), id);
                    // orphanRemoval=true ที่ choices จะช่วยลบ, แต่กันชัวร์:
                    if (q.getChoices() != null) {
                        for (QuestionChoiceEntity c : new ArrayList<>(q.getChoices())) {
                            em.remove(c);
                        }
                    }
                    // ลบ fill_blank ถ้าผูกแบบใช้ question id
                    QuestionFillBlankEntity fb = em.find(QuestionFillBlankEntity.class, q.getId());
                    if (fb != null) {
                        em.remove(fb);
                    }

                    em.remove(q);
                    it.remove();
                }
            }
        }
    } else {
        log.info("No questions provided in DTO, keep existing quiz for content {}", id);
    }

    em.flush();
    log.info("Learning content with ID: {} updated successfully in method -> {}", id, methodName);

    return LearningContentDto.withQuizInfo(lc, returnedQuestionDtos);
}
