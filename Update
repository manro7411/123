package TrainerAnalytic.Resources;

import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;
import model.TeamEntity;
import model.User;
import org.acme.security.jwt.Roles;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Trainer Analytics endpoints (new version)
 *
 * Base path: /trainer
 *
 * Key changes:
 * - NO usage of lc.team_id anymore (fixes SQL error).
 * - View supports: individual (default), team (filter on learners list).
 * - Person filter via userId (JOIN users) instead of userEmail.
 * - Team filter via p.user_email IN (emails of team members).
 */
@Path("/trainer")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class TrainerAnalyticResources {

    private static final Logger log = LoggerFactory.getLogger(TrainerAnalyticResources.class);

    @Inject EntityManager em;
    @Inject TrainerUtilities trainerUtilities;

    // ===== Helpers =====
    private static LocalDate parseDateOr(String s, LocalDate fallback) {
        if (s == null || s.isBlank()) return fallback;
        return LocalDate.parse(s);
    }
    private static LocalDateTime startOfDay(LocalDate d) { return d.atStartOfDay(); }
    private static LocalDateTime dayAfter(LocalDate d) { return d.plusDays(1).atStartOfDay(); }

    /** Resolve trainer email from token principal */
    private String resolveTrainerEmail(SecurityContext sc) {
        String email = (sc.getUserPrincipal() != null) ? sc.getUserPrincipal().getName() : null;
        if (email == null || email.isBlank()) {
            throw new WebApplicationException("Missing principal", Response.Status.UNAUTHORIZED);
        }
        return email.toLowerCase();
    }

    /** Collect lowercased emails for team members to filter progress (team view) */
    private Set<String> getTeamMemberEmailsLower(String teamId) {
        if (teamId == null || teamId.isBlank()) return Set.of();
        TeamEntity team = em.find(TeamEntity.class, teamId);
        if (team == null || team.getMembers() == null) return Set.of();

        return team.getMembers().stream()
                .filter(Objects::nonNull)
                .map(String::toLowerCase)
                .filter(Objects::nonNull)
                .map(String::trim)
                .map(String::toLowerCase)
                .collect(Collectors.toSet());
    }
    private static LocalDate toLocalDate(Object raw) {
        if (raw == null) return null;
        if (raw instanceof LocalDate d) return d;
        if (raw instanceof java.sql.Date d) return d.toLocalDate();
        if (raw instanceof java.time.LocalDateTime dt) return dt.toLocalDate();
        if (raw instanceof java.util.Date ud)
            return ud.toInstant().atZone(java.time.ZoneId.systemDefault()).toLocalDate();
        return LocalDate.parse(raw.toString());
    }

    // =========================================================================
    // 1) OVERVIEW  (supports view=team|individual, teamId, userId)
    // =========================================================================
    @GET
    @Path("/overview")
    @RolesAllowed({Roles.ROLE_TRAINER, Roles.ROLE_ADMINISTRATOR})
    public Response overview(
            @Context SecurityContext securityContext,
            @QueryParam("start") String start,
            @QueryParam("end") String end,
            @QueryParam("view") @DefaultValue("individual") String view,
            @QueryParam("teamId") String teamId,
            @QueryParam("userId") String userId // NEW: filter by users.id
    ) {
        final String trainerEmail = resolveTrainerEmail(securityContext);
        final LocalDate endDate = parseDateOr(end, LocalDate.now());
        final LocalDate startDate = parseDateOr(start, endDate.minusDays(6));
        final LocalDateTime startDT = startOfDay(startDate);
        final LocalDateTime endDT = dayAfter(endDate);

        final boolean isTeamView = "team".equalsIgnoreCase(view);
        final boolean filterUser = (userId != null && !userId.isBlank());
        final Set<String> teamEmailsLower = isTeamView ? getTeamMemberEmailsLower(teamId) : Set.of();
        final boolean hasTeamEmails = !teamEmailsLower.isEmpty();

        log.info("[trainer/overview] email={} view={} teamId={} userId={} window {}..(exclusive {})",
                trainerEmail, view, teamId, userId, startDT, endDT);

        // OWNERSHIP: only contents authored by this trainer
        final String ownerFilter = "lc.author_email = :email";

        // Learner filter (applied to progress p.*):
        // - individual: EXISTS users.id = :userId
        // - team: LOWER(p.user_email) IN (:teamEmailsLower)
        String learnerFilter = "";
        if (filterUser) {
            learnerFilter = " AND EXISTS (SELECT 1 FROM users ux WHERE ux.email = p.user_email AND ux.id = :userId) ";
        } else if (hasTeamEmails) {
            learnerFilter = " AND LOWER(p.user_email) IN (:teamEmailsLower) ";
        }

        // ---------- KPI: total contents ----------
        long totalContents = ((Number) em.createNativeQuery(
                        "SELECT COUNT(*) FROM learning_content lc WHERE " + ownerFilter)
                .setParameter("email", trainerEmail)
                .getSingleResult()).longValue();

        // ---------- KPI: active learners ----------
        String activeLearnersSql = """
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND (
                  (p.started_at   IS NOT NULL AND p.started_at   >= :start AND p.started_at   < :end)
               OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
              )
              %s
        """.formatted(ownerFilter, learnerFilter);
        Query activeLearnersQuery = em.createNativeQuery(activeLearnersSql)
                .setParameter("email", trainerEmail)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (filterUser) activeLearnersQuery.setParameter("userId", userId);
        else if (hasTeamEmails) activeLearnersQuery.setParameter("teamEmailsLower", teamEmailsLower);
        long activeLearners = ((Number) activeLearnersQuery.getSingleResult()).longValue();

        // ---------- KPI: new enrollments ----------
        String newEnrollmentsSql = """
            SELECT COUNT(*)
            FROM user_lesson_progress p
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND p.started_at IS NOT NULL
              AND p.started_at >= :start AND p.started_at < :end
              %s
        """.formatted(ownerFilter, learnerFilter);
        Query newEnrollmentsQuery = em.createNativeQuery(newEnrollmentsSql)
                .setParameter("email", trainerEmail)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (filterUser) newEnrollmentsQuery.setParameter("userId", userId);
        else if (hasTeamEmails) newEnrollmentsQuery.setParameter("teamEmailsLower", teamEmailsLower);
        long newEnrollments = ((Number) newEnrollmentsQuery.getSingleResult()).longValue();

        // ---------- KPI: completion rate & avg score ----------
        String rateSql = """
            SELECT
              AVG(CASE WHEN p.percent = 100 THEN 1.0 ELSE 0.0 END),
              AVG(p.score)
            FROM user_lesson_progress p
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND (
                  (p.started_at   IS NOT NULL AND p.started_at   >= :start AND p.started_at   < :end)
               OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
              )
              %s
        """.formatted(ownerFilter, learnerFilter);
        Query rateQuery = em.createNativeQuery(rateSql)
                .setParameter("email", trainerEmail)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (filterUser) rateQuery.setParameter("userId", userId);
        else if (hasTeamEmails) rateQuery.setParameter("teamEmailsLower", teamEmailsLower);
        Object[] rateRow = (Object[]) rateQuery.getSingleResult();
        double completionRate = rateRow[0] == null ? 0d : ((Number) rateRow[0]).doubleValue();
        Double avgScore = rateRow[1] == null ? null : ((Number) rateRow[1]).doubleValue();

        // ---------- Trend: enroll ---------
        String enrollDetailSql = """
            SELECT DATE(p.started_at), u.name, p.user_email, lc.title, p.started_at
            FROM user_lesson_progress p
            JOIN users u ON u.email = p.user_email
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND p.started_at IS NOT NULL
              AND p.started_at >= :start AND p.started_at < :end
              %s
        """.formatted(ownerFilter, learnerFilter);
        Query enrollDetailQuery = em.createNativeQuery(enrollDetailSql)
                .setParameter("email", trainerEmail)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (filterUser) enrollDetailQuery.setParameter("userId", userId);
        else if (hasTeamEmails) enrollDetailQuery.setParameter("teamEmailsLower", teamEmailsLower);
        List<Object[]> enrollDetails = enrollDetailQuery.getResultList();

        // ---------- Trend: complete ---------
        String completeDetailSql = """
            SELECT DATE(p.completed_at), u.name, p.user_email, lc.title, p.score, p.total_questions, p.completed_at
            FROM user_lesson_progress p
            JOIN users u ON u.email = p.user_email
            JOIN learning_content lc ON p.lesson_id = lc.id
            WHERE %s
              AND p.completed_at IS NOT NULL
              AND p.completed_at >= :start AND p.completed_at < :end
              %s
        """.formatted(ownerFilter, learnerFilter);
        Query completeDetailQuery = em.createNativeQuery(completeDetailSql)
                .setParameter("email", trainerEmail)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (filterUser) completeDetailQuery.setParameter("userId", userId);
        else if (hasTeamEmails) completeDetailQuery.setParameter("teamEmailsLower", teamEmailsLower);
        List<Object[]> completeDetails = completeDetailQuery.getResultList();

        // ---------- Merge trend ----------
        Map<LocalDate, Map<String, List<Map<String, Object>>>> trendMap = new LinkedHashMap<>();
        for (LocalDate d = startDate; !d.isAfter(endDate); d = d.plusDays(1)) {
            Map<String, List<Map<String, Object>>> daily = new HashMap<>();
            daily.put("enroll", new ArrayList<>());
            daily.put("complete", new ArrayList<>());
            trendMap.put(d, daily);
        }

        for (Object[] r : enrollDetails) {
            LocalDate d = ((java.sql.Date) r[0]).toLocalDate();
            if (trendMap.containsKey(d)) {
                Map<String, Object> user = Map.of(
                        "name", r[1],
                        "email", r[2],
                        "course", r[3],
                        "startedAt", r[4]
                );
                trendMap.get(d).get("enroll").add(user);
            }
        }

        for (Object[] r : completeDetails) {
            LocalDate d = ((java.sql.Date) r[0]).toLocalDate();
            if (trendMap.containsKey(d)) {
                Map<String, Object> user = Map.of(
                        "name", r[1],
                        "email", r[2],
                        "course", r[3],
                        "score", r[4],
                        "totalQuestions", r[5],
                        "CompletedAt", r[6]
                );
                trendMap.get(d).get("complete").add(user);
            }
        }

        List<Map<String, Object>> trend = new ArrayList<>();
        trendMap.forEach((date, data) -> {
            Map<String, Object> row = new LinkedHashMap<>();
            row.put("date", date.toString());
            row.put("enrollCount", data.get("enroll").size());
            row.put("completeCount", data.get("complete").size());
            row.put("enroll", data.get("enroll"));
            row.put("complete", data.get("complete"));
            trend.add(row);
        });

        Map<String, Object> kpi = new LinkedHashMap<>();
        kpi.put("totalContents", totalContents);
        kpi.put("newEnrollments", newEnrollments);
        kpi.put("completionRate", completionRate);
        kpi.put("avgScore", avgScore);

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("kpi", kpi);
        out.put("trend", trend);

        return Response.ok(out).build();
    }

    // =========================================================================
    // 2) CONTENT PERFORMANCE  (supports view + teamId + userId)
    // =========================================================================
    @GET
    @Path("/content-performance")
    @RolesAllowed({Roles.ROLE_TRAINER, Roles.ROLE_ADMINISTRATOR})
    public Response contentPerformance(
            @Context SecurityContext securityContext,
            @QueryParam("start") String start,
            @QueryParam("end") String end,
            @QueryParam("order") @DefaultValue("completionRate:desc") String order,
            @QueryParam("limit") @DefaultValue("20") int limit,
            @QueryParam("offset") @DefaultValue("0") int offset,
            @QueryParam("view") @DefaultValue("individual") String view, // NEW
            @QueryParam("teamId") String teamId,                          // NEW
            @QueryParam("userId") String userId                           // NEW
    ) {
        final String trainerEmail = resolveTrainerEmail(securityContext);
        final LocalDate endDate = parseDateOr(end, LocalDate.now());
        final LocalDate startDate = parseDateOr(start, endDate.minusDays(6));
        final LocalDateTime startDT = startOfDay(startDate);
        final LocalDateTime endDT = dayAfter(endDate);

        if (limit < 1) limit = 20;
        if (limit > 200) limit = 200;
        if (offset < 0) offset = 0;

        final boolean isTeamView = "team".equalsIgnoreCase(view);
        final boolean filterUser = (userId != null && !userId.isBlank());
        final Set<String> teamEmailsLower = isTeamView ? getTeamMemberEmailsLower(teamId) : Set.of();
        final boolean hasTeamEmails = !teamEmailsLower.isEmpty();

        String orderSql = "completion_rate DESC";
        if (order != null && !order.isBlank()) {
            String[] parts = order.split(":");
            String field = parts[0];
            String dir = parts.length > 1 ? parts[1] : "asc";
            String sortDir = "desc".equalsIgnoreCase(dir) ? "DESC" : "ASC";
            switch (field) {
                case "title" -> orderSql = "lc.title " + sortDir;
                case "learners" -> orderSql = "learners " + sortDir;
                case "avgScore" -> orderSql = "avg_score " + sortDir;
                case "completionRate" -> orderSql = "completion_rate " + sortDir;
            }
        }

        // OWNERSHIP
        final String ownerFilter = "lc.author_email = :email";

        // learner condition placed in LEFT JOIN ON-clause (to keep contents with zero progress)
        String onLearnerFilter = "";
        if (filterUser) {
            onLearnerFilter = " AND EXISTS (SELECT 1 FROM users ux WHERE ux.email = p.user_email AND ux.id = :userId) ";
        } else if (hasTeamEmails) {
            onLearnerFilter = " AND LOWER(p.user_email) IN (:teamEmailsLower) ";
        }

        // ---------- main ----------
        String sql = ("""
            SELECT
              lc.id AS content_id,
              lc.title AS title,
              COUNT(DISTINCT p.user_email) AS learners,
              AVG(CASE WHEN p.percent = 100 THEN 1.0 ELSE 0.0 END) AS completion_rate,
              AVG(p.score) AS avg_score
            FROM learning_content lc
            LEFT JOIN user_lesson_progress p ON p.lesson_id = lc.id
              AND (
                   (p.started_at   IS NOT NULL AND p.started_at   >= :start AND p.started_at   < :end)
                OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
              )
              %s
            WHERE %s
            GROUP BY lc.id, lc.title
            ORDER BY %s
        """).formatted(onLearnerFilter, ownerFilter, orderSql);

        Query q = em.createNativeQuery(sql)
                .setParameter("email", trainerEmail)
                .setParameter("start", startDT)
                .setParameter("end", endDT);
        if (filterUser) q.setParameter("userId", userId);
        else if (hasTeamEmails) q.setParameter("teamEmailsLower", teamEmailsLower);
        q.setFirstResult(offset);
        q.setMaxResults(limit);

        @SuppressWarnings("unchecked")
        List<Object[]> rows = q.getResultList();

        // ---------- learners detail ----------
        List<String> contentIds = rows.stream().map(r -> String.valueOf(r[0])).toList();
        Map<String, List<Map<String, Object>>> learnersByContent = new HashMap<>();
        if (!contentIds.isEmpty()) {
            String detailLearnerFilter =
                    filterUser
                            ? " AND u.id = :userId "
                            : (hasTeamEmails ? " AND LOWER(p.user_email) IN (:teamEmailsLower) " : "");

            String learnerSql = ("""
                SELECT
                  p.lesson_id AS content_id,
                  u.name AS learner_name,
                  p.user_email,
                  p.percent,
                  p.score
                FROM user_lesson_progress p
                JOIN users u ON u.email = p.user_email
                JOIN learning_content lc ON lc.id = p.lesson_id
                WHERE p.lesson_id IN :contentIds
                  AND (
                       (p.started_at   IS NOT NULL AND p.started_at   >= :start AND p.started_at   < :end)
                    OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
                  )
                  %s
                  AND %s
            """).formatted(detailLearnerFilter, ownerFilter);

            Query learnerQuery = em.createNativeQuery(learnerSql)
                    .setParameter("contentIds", contentIds)
                    .setParameter("start", startDT)
                    .setParameter("end", endDT)
                    .setParameter("email", trainerEmail);
            if (filterUser) learnerQuery.setParameter("userId", userId);
            else if (hasTeamEmails) learnerQuery.setParameter("teamEmailsLower", teamEmailsLower);

            @SuppressWarnings("unchecked")
            List<Object[]> learnerRows = learnerQuery.getResultList();
            for (Object[] r : learnerRows) {
                String cid = String.valueOf(r[0]);
                Map<String, Object> learner = new LinkedHashMap<>();
                learner.put("name", r[1]);
                learner.put("email", r[2]);
                learner.put("percent", r[3]);
                learner.put("score", r[4]);
                learnersByContent.computeIfAbsent(cid, k -> new ArrayList<>()).add(learner);
            }
        }

        List<Map<String, Object>> items = new ArrayList<>(rows.size());
        for (Object[] r : rows) {
            String cid = String.valueOf(r[0]);
            Map<String, Object> m = new LinkedHashMap<>();
            m.put("contentId", cid);
            m.put("title", r[1]);
            m.put("learnersCount", ((Number) (r[2] == null ? 0 : r[2])).longValue());
            m.put("completionRate", r[3] == null ? 0d : ((Number) r[3]).doubleValue());
            m.put("avgScore", r[4] == null ? null : ((Number) r[4]).doubleValue());
            m.put("learners", learnersByContent.getOrDefault(cid, List.of()));
            items.add(m);
        }

        Number total = (Number) em.createNativeQuery("""
            SELECT COUNT(*) FROM learning_content lc WHERE %s
        """.formatted(ownerFilter))
                .setParameter("email", trainerEmail)
                .getSingleResult();

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("items", items);
        out.put("total", total.longValue());
        out.put("limit", limit);
        out.put("offset", offset);
        return Response.ok(out).build();
    }

    // =========================================================================
    // 3) CONTENT FUNNEL (unchanged ownership check by author_email)
    // =========================================================================
    @GET
    @Path("/content-funnel")
    @RolesAllowed({Roles.ROLE_TRAINER,Roles.ROLE_ADMINISTRATOR})
    public Response contentFunnel(
            @Context SecurityContext securityContext,
            @QueryParam("contentId") String contentId,
            @QueryParam("start") String start,
            @QueryParam("end")   String end
    ) {
        if (contentId == null || contentId.isBlank()) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(Map.of("error", "Missing contentId")).build();
        }
        final String trainerEmail = resolveTrainerEmail(securityContext);
        final LocalDate endDate   = parseDateOr(end, LocalDate.now());
        final LocalDate startDate = parseDateOr(start, endDate.minusDays(6));
        final LocalDateTime startDT = startOfDay(startDate);
        final LocalDateTime endDT   = dayAfter(endDate);

        Number owned = (Number) em.createNativeQuery("""
            SELECT COUNT(*) FROM learning_content lc WHERE lc.id = :cid AND lc.author_email = :email
        """).setParameter("cid", contentId)
                .setParameter("email", trainerEmail)
                .getSingleResult();
        if (owned.intValue() == 0) {
            return Response.status(Response.Status.FORBIDDEN)
                    .entity(Map.of("error","Content not owned by trainer")).build();
        }

        Number enrolled = (Number) em.createNativeQuery("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            WHERE p.lesson_id = :cid
              AND p.started_at IS NOT NULL
              AND p.started_at >= :start AND p.started_at < :end
        """).setParameter("cid", contentId)
                .setParameter("start", startDT)
                .setParameter("end", endDT)
                .getSingleResult();

        Number half = (Number) em.createNativeQuery("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            WHERE p.lesson_id = :cid
              AND p.percent >= 50
              AND (
                   (p.started_at  IS NOT NULL AND p.started_at  >= :start AND p.started_at  < :end)
                OR (p.completed_at IS NOT NULL AND p.completed_at >= :start AND p.completed_at < :end)
              )
        """).setParameter("cid", contentId)
                .setParameter("start", startDT)
                .setParameter("end", endDT)
                .getSingleResult();

        Number completed = (Number) em.createNativeQuery("""
            SELECT COUNT(DISTINCT p.user_email)
            FROM user_lesson_progress p
            WHERE p.lesson_id = :cid
              AND p.completed_at IS NOT NULL
              AND p.completed_at >= :start AND p.completed_at < :end
        """).setParameter("cid", contentId)
                .setParameter("start", startDT)
                .setParameter("end", endDT)
                .getSingleResult();

        Map<String, Object> out = new LinkedHashMap<>();
        out.put("contentId", contentId);
        out.put("funnel", Map.of(
                "enrolled",  enrolled.longValue(),
                "started",   enrolled.longValue(),
                "half",      half.longValue(),
                "completed", completed.longValue()
        ));
        return Response.ok(out).build();
    }

    // (Optional helper endpoint still available)
    @GET
    @Path("/assignable-teams")
    @RolesAllowed({Roles.ROLE_TRAINER})
    public Response getAssignableTeams(@Context SecurityContext sc) {
        String trainerEmail = sc.getUserPrincipal().getName();
        log.info("Incoming Info: get assignable teams for trainer {}", trainerEmail);
        User trainer = em.createQuery("SELECT u FROM User u WHERE u.email = :email", User.class)
                .setParameter("email", trainerEmail)
                .getSingleResult();

        List<TeamEntity> teams = trainerUtilities.getTeamsAssignedToTrainer(trainer.getEmail());

        List<Map<String, String>> result = teams.stream()
                .map(team -> Map.of(
                        "id", team.getId(),
                        "name", team.getName(),
                        "description", team.getDescription()
                ))
                .collect(Collectors.toList());

        return Response.ok(result).build();
    }
}
