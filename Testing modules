package QuizService.Entity;

import jakarta.persistence.*;

import java.util.UUID;

@Entity
@Table(name = "quiz_answers")
public class QuizAnswerEntity {

    @Id
    @GeneratedValue
    private UUID id;

    @ManyToOne(optional = false)
    @JoinColumn(name = "attempt_id")
    private QuizAttemptEntity attempt;

    @ManyToOne(optional = false)
    @JoinColumn(name = "question_id")
    private QuestionEntity question;

    @Column(name = "selected_choice_id", length = 21)
    private String selectedChoiceId;

    @Column(name = "is_correct")
    private boolean isCorrect;

    public UUID getId() {return id;}

    public void setId(UUID id) {this.id = id;}

    public QuizAttemptEntity getAttempt() {return attempt;}

    public void setAttempt(QuizAttemptEntity attempt) {this.attempt = attempt;}

    public QuestionEntity getQuestion() {return question;}

    public void setQuestion(QuestionEntity question) {this.question = question;}

    public String getSelectedChoiceId() {return selectedChoiceId;}

    public void setSelectedChoiceId(String selectedChoiceId) {this.selectedChoiceId = selectedChoiceId;}

    public boolean isCorrect() {return isCorrect;}

    public void setCorrect(boolean correct) {isCorrect = correct;}
}
package QuizService.Entity;

import jakarta.persistence.*;
import model.User;
import model.UserLessonProgress;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "quiz_attempts")
public class QuizAttemptEntity {
    @Id
    @GeneratedValue
    private UUID id;

    @ManyToOne(optional = false)
    @JoinColumn(name = "user_email",referencedColumnName = "email")
    private User user;

    @ManyToOne(optional = false)
    @JoinColumn(name = "lesson_progress_id")
    private UserLessonProgress lessonProgress;

    @Column(name = "attempted_at" , nullable = false)
    private LocalDateTime attemptedAt;

    @Column(name = "score")
    private Integer score;

    @Column(name = "max_score")
    private Integer maxScore;

    @OneToMany(mappedBy = "attempt", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<QuizAnswerEntity> answers = new ArrayList<>();

    public UUID getId() {return id;}

    public void setId(UUID id) {this.id = id;}

    public User getUser() {return user;}

    public void setUser(User user) {this.user = user;}

    public UserLessonProgress getLessonProgress() {return lessonProgress;}

    public void setLessonProgress(UserLessonProgress lessonProgress) {this.lessonProgress = lessonProgress;}

    public LocalDateTime getAttemptedAt() {return attemptedAt;}

    public void setAttemptedAt(LocalDateTime attemptedAt) {this.attemptedAt = attemptedAt;}

    public Integer getScore() {return score;}

    public void setScore(Integer score) {this.score = score;}

    public Integer getMaxScore() {return maxScore;}

    public void setMaxScore(Integer maxScore) {this.maxScore = maxScore;}

    public List<QuizAnswerEntity> getAnswers() {return answers;}

    public void setAnswers(List<QuizAnswerEntity> answers) {this.answers = answers;}
}
@POST
    @Path("/{lessonId}/submit-answers")
    @Transactional
    @RolesAllowed({Roles.ROLE_USER, Roles.ROLE_TRAINER, Roles.ROLE_ADMINISTRATOR})
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response submitAnswers(@PathParam("lessonId") String lessonId, QuizSubmissionDTO submission, @Context SecurityContext securityContext) {
        String currentUser = securityContext.getUserPrincipal().getName();
        String method = Thread.currentThread().getStackTrace()[1].getMethodName();
        log.info("User {} is calling {}() for lessonId: {}", currentUser, method, lessonId);

        if (submission.answers == null || submission.answers.isEmpty()) {
            log.info("Answers are required.");
            throw new BadRequestException("Answers are required.");
        }

        var progress = em.createQuery("""
        SELECT p FROM UserLessonProgress p
        WHERE p.lessonId = :lessonId AND p.userEmail = :userEmail
        """, UserLessonProgress.class)
                .setParameter("lessonId", lessonId)
                .setParameter("userEmail", currentUser)
                .getResultStream()
                .findFirst()
                .orElseThrow(() -> new NotFoundException("No progress found. Please watch the lesson first."));

        if (progress.getPercent() < 100) {
            log.info("You must complete the lesson before submitting answers.");
            throw new BadRequestException("You must complete the lesson before submitting answers.");
        }

        LearningContent lesson = em.find(LearningContent.class, lessonId);
        if (lesson == null) {
            log.info("Lesson not found");
            throw new NotFoundException("Lesson not found.");
        }

        int maxAttempts = Optional.ofNullable(lesson.getMaxAttempts()).orElse(1);
        int currentAttempts = Optional.ofNullable(progress.getAttempts()).orElse(0);
        if (currentAttempts >= maxAttempts) {
            log.info("You have reached the maximum number of attempts.");
            throw new BadRequestException("You have reached the maximum number of attempts.");
        }
        QuizAttemptEntity attempt = new QuizAttemptEntity();
        attempt.setUser(em.find(User.class, currentUser));
        attempt.setLessonProgress(progress);
        em.persist(attempt);

        int score = 0;
        int maxScore = 0;

        for (AnswerDTO answer : submission.answers) {
            QuestionEntity question = em.find(QuestionEntity.class, answer.questionId);
            if (question == null || !question.getLearningContent().getId().equals(lessonId)) {
                log.info("Invalid question or mismatched lesson.");
                throw new BadRequestException("Invalid question or mismatched lesson.");
            }

            QuestionChoiceEntity selectedChoice = em.find(QuestionChoiceEntity.class, answer.selectedChoiceId);
            boolean isCorrect = selectedChoice != null && selectedChoice.isCorrect;

            QuizAnswerEntity qa = new QuizAnswerEntity();
            qa.setAttempt(attempt);
            qa.setQuestion(question);
            qa.setSelectedChoiceId(answer.selectedChoiceId);
            qa.setCorrect(isCorrect);
            em.persist(qa);

            maxScore += question.getPoints();
            if (isCorrect) score += question.getPoints();
        }

        attempt.setScore(score);
        attempt.setMaxScore(maxScore);

        // Update progress
        progress.setAttempts(currentAttempts + 1);
        progress.setScore(score);
        progress.setTotalQuestions(submission.answers.size());
        progress.setUpdatedAt(LocalDateTime.now());

        int percentScore = (int) Math.round((score * 100.0) / Math.max(maxScore, 1));

        LearningScoreEntity learningScore = new LearningScoreEntity();
        learningScore.setLessonId(lessonId);
        learningScore.setUserEmail(currentUser);
        learningScore.setOverallScore(0);
        learningScore.setUpdatedAt(LocalDateTime.now());
        em.persist(learningScore);

        log.info("Quiz submitted: score={}, maxScore={}", score, maxScore);

        return Response.ok().entity(Map.of(
                "score", score,
                "maxScore", maxScore,
                "percentScore", percentScore,
                "attemptId", attempt.getId()
        )).build();
    }
@PUT
    @Path("/{lessonId}/submit-score")
    @Transactional
    @RolesAllowed({Roles.ROLE_USER,Roles.ROLE_TRAINER,Roles.ROLE_ADMINISTRATOR})
    public Response submitScore(@PathParam("lessonId") String lessonId, SubmitScoreRequest req, @Context SecurityContext securityContext) {
        String currentUser = securityContext.getUserPrincipal().getName();
        String method = Thread.currentThread().getStackTrace()[1].getMethodName();
        String userEmail = jwt.getSubject();
        log.info("User {} is calling {}() for lessonId: {}", currentUser, method, lessonId);

        var progress = em.createQuery("""
        SELECT p FROM UserLessonProgress p
        WHERE p.lessonId = :lessonId AND p.userEmail = :userEmail
        """, UserLessonProgress.class)
                .setParameter("lessonId", lessonId)
                .setParameter("userEmail", userEmail)
                .getResultStream()
                .findFirst()
                .orElseThrow(() -> new NotFoundException("No progress found. Please watch the lesson first."));

        if (progress.getPercent() < 100) {
            log.warn("User {} attempted to submit score without completing lesson {}", userEmail, lessonId);
            throw new BadRequestException("You must complete the lesson (100%) before submitting score");
        }

        LearningContent lesson = em.find(LearningContent.class, lessonId);
        if (lesson == null){
            log.error("Lesson with ID {} not found for score submission", lessonId);
            throw new NotFoundException("Lesson not found.");
        }

        int maxAttempts = Optional.ofNullable(lesson.getMaxAttempts()).orElse(1);
        int currentAttempts = Optional.ofNullable(progress.getAttempts()).orElse(0);
        if (currentAttempts >= maxAttempts) {
            log.warn("User {} has reached max attempts for lesson {}", userEmail, lessonId);
            throw new BadRequestException("You have reached the maximum number of attempts for this quiz.");
        }

        int score = req.score;
        int totalQuestions = req.totalQuestions;
        int percentScore = (int) Math.round((score * 100.0) / totalQuestions);
        int levelScore;

        if (percentScore >= 100) {
            levelScore = 5;
        } else if (percentScore >= 80) {
            levelScore = 4;
        } else if (percentScore >= 70) {
            levelScore = 3;
        } else if (percentScore >= 60) {
            levelScore = 2;
        } else if (percentScore >= 50) {
            levelScore = 1;
        } else {
            levelScore = 0;
        }
        log.info("User {} scored {}/{} ({}%) => Level Score: {}", userEmail, score, totalQuestions, percentScore, levelScore);

        progress.setAttempts(currentAttempts + 1);
        progress.setScore(score);
        progress.setTotalQuestions(totalQuestions);
        progress.setUpdatedAt(LocalDateTime.now());

        LearningScoreEntity learningScore = new LearningScoreEntity();
        learningScore.setLessonId(lessonId);
        learningScore.setUserEmail(userEmail);
        learningScore.setOverallScore(levelScore);
        learningScore.setUpdatedAt(LocalDateTime.now());
        em.persist(learningScore);

        log.info("Learning score of {} added for user {} on lesson {}", levelScore, userEmail, lessonId);
        return Response.ok().build();
    }
