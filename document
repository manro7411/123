import { useContext, useEffect, useMemo, useRef, useState } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import axios from "axios";
import { AuthContext } from "../../Authentication/AuthContext";
import Sidebar from "../../widgets/SidebarWidget";
import defaultUserAvatar from "../../assets/user.png";
import ChatBubbleWidget from "../../widgets/ChatBubbleWidget";
import NotificationWidget from "../../widgets/NotificationWidget";
import { useLesson } from "./hooks/useLessons";
import { useUserProfile } from "./hooks/useUserProfile";
import { useTeam } from "./hooks/useTeam";
import { CATEGORY_GROUPS } from "./constants/categories"; // <--- moved to separate file

// Utility to normalize a lesson's category to a {group, sub} path based on the config above.
function resolveCategoryPath(raw?: string): { group: string; sub: string | null; path: string } {
  const value = (raw ?? "").trim();
  if (!value) return { group: "Others", sub: null, path: "Others" };

  if (value.includes(">")) {
    const [g, s] = value.split(">").map((v) => v.trim());
    const group = CATEGORY_GROUPS[g] ? g : "Others";
    const sub = s || null;
    return { group, sub, path: sub ? `${group}/${sub}` : group };
  }

  for (const [group, subs] of Object.entries(CATEGORY_GROUPS)) {
    if (subs.includes(value)) return { group, sub: value, path: `${group}/${value}` };
  }

  if (CATEGORY_GROUPS[value]) return { group: value, sub: null, path: value };

  return { group: "Others", sub: value || null, path: value ? `Others/${value}` : "Others" };
}

function countByPath(paths: string[]): Record<string, number> {
  return paths.reduce((acc, p) => {
    acc[p] = (acc[p] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
}

const LessonPage = () => {
  const { token: ctxToken } = useContext(AuthContext);
  const token = ctxToken || localStorage.getItem("token") || sessionStorage.getItem("token");
  const navigate = useNavigate();
  const location = useLocation();
  const menuRef = useRef<HTMLDivElement>(null);

  const [searchQuery, setSearchQuery] = useState("");
  const [categoryMenuOpen, setCategoryMenuOpen] = useState(false);
  const [selectedPaths, setSelectedPaths] = useState<string[]>([]);
  const [selectedAssignType, setSelectedAssignType] = useState<string>("all");

  const { lessons, progressMap, loading } = useLesson(token, location.pathname);
  const { userId } = useUserProfile(token);
  const myTeamIds = useTeam(token);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setCategoryMenuOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const lessonsWithPath = useMemo(() => {
    return lessons.map((l) => {
      const cat = resolveCategoryPath(l.category);
      return { ...l, __cat: cat } as typeof l & {
        __cat: { group: string; sub: string | null; path: string };
      };
    });
  }, [lessons]);

  const allPaths = useMemo(() => lessonsWithPath.map((l) => l.__cat.path), [lessonsWithPath]);
  const pathCounts = useMemo(() => countByPath(allPaths), [allPaths]);

  const togglePath = (path: string) => {
    setSelectedPaths((prev) =>
      prev.includes(path) ? prev.filter((p) => p !== path) : [...prev, path]
    );
  };

  const clearAllSelections = () => setSelectedPaths([]);

  const selectEntireGroup = (group: string) => {
    const subs = CATEGORY_GROUPS[group] ?? [];
    const groupPath = group;
    setSelectedPaths((prev) => {
      const withoutGroup = prev.filter((p) => !p.startsWith(`${group}/`) && p !== group);
      return [...withoutGroup, groupPath];
    });
  };

  const filteredLessons = useMemo(() => {
    return lessonsWithPath.filter((lesson) => {
      const key = lesson.id.toLowerCase();
      const progress = progressMap[key]?.percent ?? 0;
      const isIncomplete = progress < 100;

      const matchesAssignType =
        selectedAssignType === "all"
          ? lesson.assignType === "all"
          : selectedAssignType === "specific"
          ? lesson.assignType === "specific" && userId && lesson.assignedUserIds?.includes(userId)
          : selectedAssignType === "team"
          ? lesson.assignType === "team" && lesson.assignedTeamIds?.some((id: string) => myTeamIds.includes(id))
          : false;

      const matchesSearch = [lesson.title, lesson.category, lesson.description ?? ""]
        .filter(Boolean)
        .some((v) => v.toLowerCase().includes(searchQuery.toLowerCase()));

      const { group, path } = lesson.__cat;
      const hasSelection = selectedPaths.length > 0;
      const matchesCategory = !hasSelection ? true : selectedPaths.some((p) => p === group || p === path);

      return isIncomplete && matchesAssignType && matchesSearch && matchesCategory;
    });
  }, [lessonsWithPath, progressMap, selectedAssignType, userId, myTeamIds, searchQuery, selectedPaths]);

  const grouped = useMemo(() => {
    const map = new Map<string, Map<string | "__root__", typeof filteredLessons>>();
    for (const l of filteredLessons) {
      const g = l.__cat.group;
      const s = l.__cat.sub ?? "__root__";
      if (!map.has(g)) map.set(g, new Map());
      const subMap = map.get(g)!;
      if (!subMap.has(s)) subMap.set(s, []);
      subMap.get(s)!.push(l);
    }
    return map;
  }, [filteredLessons]);

  const handleLessonClick = async (id: string) => {
    const key = id.toLowerCase();
    const lastTimestamp = progressMap[key]?.lastTimestamp || 0;

    try {
      await axios.post(`/api/learning/${id}/click`, {}, { headers: { Authorization: `Bearer ${token}` } });
    } catch (err) {
      console.error("Failed to log click:", err);
    } finally {
      navigate(`/lesson/${id}`, { state: { lastTimestamp } });
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex">
      <Sidebar />
      <main className="flex-1 p-6">
        {/* ... (same render code as before) */}
      </main>
      <ChatBubbleWidget />
    </div>
  );
};

export default LessonPage;

// LessonCard component (same as before)
