package LearningReport.Resources;

import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.persistence.EntityManager;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import model.MemberEntity;
import model.TeamEntity;
import model.UserLessonProgress;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Path("/report/learning")
@RolesAllowed("supervisor")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class SupervisorLearningReportResource {

    private static final Logger log = LoggerFactory.getLogger(SupervisorLearningReportResource.class);

    @Inject
    EntityManager entityManager;

    /**
     * GET /reports/learning?teamId=...&start=YYYY-MM-DD&end=YYYY-MM-DD&userId=(optional)
     * - teamId: บังคับ
     * - start/end: ถ้าไม่ส่ง จะ default = 7 วันล่าสุด
     * - userId: ถ้าส่ง จะกรองรายบุคคล (ในทีม)
     */

    @GET
    public Response getReport(@QueryParam("teamId") String teamId,
                              @QueryParam("start") String startStr,
                              @QueryParam("end") String endStr,
                              @QueryParam("userId") String filterUserId) {
        String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();
        log.info("Fetching report: method={}, teamId={}, startDate={}, endDate={}, filterUserId={}",
                methodName, teamId, startStr, endStr, filterUserId);
        if (teamId == null || teamId.isEmpty()) {
            log.warn("teamId is missing in the request");
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity("teamId is required").build();
        }
        LocalDate startDate = (startStr == null || startStr.isEmpty()) ?
                LocalDate.now().minusDays(7) : LocalDate.parse(startStr);
        LocalDate endDate = (endStr == null || endStr.isEmpty()) ?
                LocalDate.now() : LocalDate.parse(endStr);
        if (startDate.isAfter(endDate)) {
            log.warn("Invalid date range: startDate {} is after endDate {}", startDate, endDate);
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity("start date must be before or equal to end date").build();
        }
        LocalDateTime startAt = startDate.atStartOfDay();
        LocalDateTime endAt = endDate.atTime(LocalTime.MAX);

        TeamEntity team = entityManager.find(TeamEntity.class, teamId);
        if (team == null) {
            log.warn("Team not found for teamId: {}", teamId);
            return Response.status(Response.Status.NOT_FOUND)
                    .entity("Team not found: "+teamId).build();
        }
        team.getMemberEntities().size();
        log.info("Team {} has {} members", team.getName(), team.getMemberEntities().size());
        List<MemberEntity> teamMembers = team.getMemberEntities().stream().filter(m -> m.getMemberId() != null &&  !m.getMemberId().isBlank()).toList();

        // 1. Collect memberIds from team members
        log.info("Step 1: Collecting member IDs from team members");
        Set<String> memberIds = teamMembers.stream()
                .map(MemberEntity::getMemberId)
                .map(String::toLowerCase)
                .collect(Collectors.toCollection(LinkedHashSet::new));
        log.info("Collected {} member IDs: {}", memberIds.size(), memberIds);

        // 2. If filtering by userId, check and reduce memberIds
                if (filterUserId != null && !filterUserId.isBlank()) {
                    String target = filterUserId.toLowerCase();
                    log.info("Step 2: Filtering by userId: {}", target);
                    if (!memberIds.contains(target)) {
                        log.warn("User {} is not in team {}", target, teamId);
                        return Response.status(Response.Status.BAD_REQUEST)
                                .entity("User " + target + " is not in team " + teamId).build();
                    }
                    memberIds = new LinkedHashSet<>(List.of(target));
                    log.info("Filtered memberIds to single user: {}", memberIds);
                }

        // 3. Map memberIds to user emails
                log.info("Step 3: Mapping member IDs to user emails");
                Set<String> userEmails = new LinkedHashSet<>(
                        entityManager.createQuery("""
                SELECT u.email FROM User u WHERE LOWER(u.id) IN :ids
            """, String.class)
                                .setParameter("ids", memberIds)
                                .getResultList()
                ).stream().map(String::toLowerCase).collect(Collectors.toSet());
                log.info("Mapped to {} user emails: {}", userEmails.size(), userEmails);

        // 4. Query progress by user emails
                log.info("Step 4: Querying UserLessonProgress between {} and {}", startAt, endAt);
                List<UserLessonProgress> progresses = entityManager.createQuery("""
            SELECT p FROM UserLessonProgress p
            WHERE LOWER(p.userEmail) IN :emails
              AND (
                   (p.updatedAt BETWEEN :startAt AND :endAt)
                OR (p.completedAt IS NOT NULL AND p.completedAt BETWEEN :startAt AND :endAt)
              )
            """, UserLessonProgress.class)
                        .setParameter("emails", userEmails)
                        .setParameter("startAt", startAt)
                        .setParameter("endAt", endAt)
                        .getResultList();
                log.info("Retrieved {} progress records", progresses.size());

        return Response.ok().entity("Everything is okay").build();
    }



}
